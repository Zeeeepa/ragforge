{
  "sessionId": "session_1764847546580",
  "question": "What is the purpose of StructuredLLMExecutor?",
  "startTime": "2025-12-04T11:25:46.580Z",
  "mode": "structured",
  "tools": [
    "get_schema",
    "describe_entity",
    "query_entities",
    "semantic_search",
    "explore_relationships",
    "get_entity_by_id",
    "get_entities_by_ids",
    "batch_analyze"
  ],
  "entries": [
    {
      "timestamp": "2025-12-04T11:25:46.580Z",
      "type": "start",
      "data": {
        "question": "What is the purpose of StructuredLLMExecutor?",
        "mode": "structured",
        "tools": [
          "get_schema",
          "describe_entity",
          "query_entities",
          "semantic_search",
          "explore_relationships",
          "get_entity_by_id",
          "get_entities_by_ids",
          "batch_analyze"
        ]
      }
    },
    {
      "timestamp": "2025-12-04T11:25:49.371Z",
      "type": "tool_call",
      "data": {
        "toolName": "get_schema",
        "arguments": {}
      }
    },
    {
      "timestamp": "2025-12-04T11:25:49.373Z",
      "type": "tool_result",
      "data": {
        "toolName": "get_schema",
        "result": {
          "entities": [
            "Scope"
          ],
          "entity_details": {
            "Scope": {
              "name": "Scope",
              "unique_field": "uuid",
              "display_name_field": "name",
              "query_field": "name",
              "content_field": "source",
              "fields": [
                {
                  "name": "name",
                  "type": "string",
                  "is_unique": false
                },
                {
                  "name": "file",
                  "type": "string",
                  "is_unique": false
                },
                {
                  "name": "source",
                  "type": "string",
                  "is_unique": false
                }
              ],
              "has_semantic_search": true,
              "semantic_indexes": [
                "scopeSourceEmbeddings"
              ],
              "outgoing_relationships": [
                "DEFINED_IN -> File",
                "CONSUMES -> Scope",
                "HAS_PARENT -> Scope",
                "USES_LIBRARY -> ExternalLibrary",
                "INHERITS_FROM -> Scope"
              ],
              "incoming_relationships": [
                "Scope -> CONSUMES",
                "Scope -> HAS_PARENT",
                "Scope -> INHERITS_FROM"
              ],
              "hierarchical_content": {
                "children_relationship": "HAS_PARENT",
                "include_children": true
              }
            }
          },
          "relationships": [
            {
              "type": "DEFINED_IN",
              "from": "Scope",
              "to": "File",
              "description": "Scope DEFINED_IN File"
            },
            {
              "type": "CONSUMES",
              "from": "Scope",
              "to": "Scope",
              "description": "Scope CONSUMES Scope"
            },
            {
              "type": "HAS_PARENT",
              "from": "Scope",
              "to": "Scope",
              "description": "Scope HAS_PARENT Scope"
            },
            {
              "type": "USES_LIBRARY",
              "from": "Scope",
              "to": "ExternalLibrary",
              "description": "Scope USES_LIBRARY ExternalLibrary"
            },
            {
              "type": "INHERITS_FROM",
              "from": "Scope",
              "to": "Scope",
              "description": "Scope INHERITS_FROM Scope"
            }
          ],
          "semantic_indexes": [
            {
              "name": "scopeSourceEmbeddings",
              "entity": "Scope",
              "source_field": "source",
              "description": "Semantic search on Scope.source"
            }
          ],
          "usage_tips": [
            "Use query_entities for structured queries with filters (=, CONTAINS, GLOB, REGEX, IN)",
            "Use semantic_search for natural language queries on: Scope.source",
            "IMPORTANT: semantic_search returns metadata + snippet only, NOT full content",
            "Use get_entities_by_ids to fetch full content (Scope.source) after semantic_search",
            "Recommended workflow: semantic_search ‚Üí get_entities_by_ids ‚Üí answer with actual content",
            "HIERARCHICAL: Scope content may be split across parent/children. If content_field is short, use explore_relationships with HAS_PARENT (direction: incoming) to fetch children",
            "Use explore_relationships to traverse connections between entities",
            "Use get_entity_by_id for a single entity, get_entities_by_ids for multiple"
          ]
        },
        "durationMs": 0
      }
    },
    {
      "timestamp": "2025-12-04T11:25:52.633Z",
      "type": "tool_call",
      "data": {
        "toolName": "semantic_search",
        "arguments": {
          "entity_type": "Scope",
          "query": "purpose of StructuredLLMExecutor"
        }
      }
    },
    {
      "timestamp": "2025-12-04T11:25:53.069Z",
      "type": "tool_result",
      "data": {
        "toolName": "semantic_search",
        "result": {
          "entity_type": "Scope",
          "query": "purpose of StructuredLLMExecutor",
          "count": 5,
          "index_used": "scopeSourceEmbeddings",
          "unique_field": "uuid",
          "results": [
            {
              "uuid": "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF",
              "name": "StructuredLLMExecutor",
              "type": "class",
              "file": "runtime/src/llm/structured-llm-executor.ts",
              "score": "0.919",
              "snippet": "export class StructuredLLMExecutor {"
            },
            {
              "uuid": "FA464EBE-5805-CD7C-D0C9-CA604B179C0E",
              "name": "StructuredLLMExecutor",
              "type": "class",
              "file": "runtime/src/llm/structured-llm-executor.ts",
              "score": "0.919",
              "snippet": "export class StructuredLLMExecutor {"
            },
            {
              "uuid": "14F0641D-7890-BA24-F679-BB9B30991171",
              "name": "constructor",
              "type": "method",
              "file": "runtime/src/summarization/generic-summarizer.ts",
              "score": "0.827",
              "snippet": "constructor(\n    private llmProvider: LLMProvider,\n    private strategies: Map<string, SummaryStrategy>,\n    private customTemplates: Map<string, string> = new Map()\n  ) {\n    this.executor = new Stru"
            },
            {
              "uuid": "CB2E4F4A-B412-22B5-8E56-300B25FACA7F",
              "name": "constructor",
              "type": "method",
              "file": "runtime/src/reranking/llm-reranker.ts",
              "score": "0.807",
              "snippet": "constructor(\n    private llmProvider: LLMProvider,\n    private options: LLMRerankOptions = {},\n    entityContext: EntityContext\n  ) {\n    this.entityContext = entityContext;\n    this.executor = new St"
            },
            {
              "uuid": "96457CE2-607C-8AEA-54C6-BDCBAA0982FE",
              "name": "executeLLMBatchWithTools",
              "type": "method",
              "file": "runtime/src/llm/structured-llm-executor.ts",
              "score": "0.806",
              "snippet": "async executeLLMBatchWithTools<TInput, TOutput>(\n    items: TInput[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): Promise<(TInput & TOutput)[] | LLMBatchResult<TInput, TOutput, any>> {\n "
            }
          ]
        },
        "durationMs": 436
      }
    },
    {
      "timestamp": "2025-12-04T11:25:57.042Z",
      "type": "tool_call",
      "data": {
        "toolName": "get_entities_by_ids",
        "arguments": {
          "entity_type": "Scope",
          "ids": [
            "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF"
          ],
          "fields": [
            "source"
          ]
        }
      }
    },
    {
      "timestamp": "2025-12-04T11:25:57.084Z",
      "type": "tool_result",
      "data": {
        "toolName": "get_entities_by_ids",
        "result": {
          "entity_type": "Scope",
          "unique_field": "uuid",
          "content_field": "source",
          "requested_ids": 1,
          "found": 1,
          "fields_returned": [
            "uuid",
            "source"
          ],
          "results": [
            {
              "uuid": "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF",
              "source": "export class StructuredLLMExecutor {"
            }
          ],
          "hint": "Some entities have very short content. This entity type has hierarchical content - use with_children=true to also fetch children (via HAS_PARENT) for complete content."
        },
        "durationMs": 42
      }
    },
    {
      "timestamp": "2025-12-04T11:26:00.545Z",
      "type": "tool_call",
      "data": {
        "toolName": "get_entity_by_id",
        "arguments": {
          "entity_type": "Scope",
          "id_value": "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF"
        }
      }
    },
    {
      "timestamp": "2025-12-04T11:26:00.574Z",
      "type": "tool_result",
      "data": {
        "toolName": "get_entity_by_id",
        "result": {
          "entity_type": "Scope",
          "unique_field": "uuid",
          "endLine": 2210,
          "complexity": 0,
          "signature": "class StructuredLLMExecutor()",
          "startLine": 240,
          "language": "typescript",
          "source": "export class StructuredLLMExecutor {",
          "type": "class",
          "uuid": "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF",
          "linesOfCode": 1971,
          "depth": 0,
          "file": "runtime/src/llm/structured-llm-executor.ts",
          "name": "StructuredLLMExecutor",
          "hash": "ae6a12b9"
        },
        "durationMs": 28
      }
    },
    {
      "timestamp": "2025-12-04T11:26:04.068Z",
      "type": "tool_call",
      "data": {
        "toolName": "get_entities_by_ids",
        "arguments": {
          "entity_type": "Scope",
          "ids": [
            "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF"
          ],
          "with_children": true
        }
      }
    },
    {
      "timestamp": "2025-12-04T11:26:04.382Z",
      "type": "tool_result",
      "data": {
        "toolName": "get_entities_by_ids",
        "result": {
          "entity_type": "Scope",
          "unique_field": "uuid",
          "content_field": "source",
          "requested_ids": 1,
          "found": 1,
          "fields_returned": [
            "uuid",
            "name",
            "source"
          ],
          "results": [
            {
              "uuid": "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF",
              "name": "StructuredLLMExecutor",
              "source": "export class StructuredLLMExecutor {"
            }
          ],
          "children_by_parent": {
            "DDC93BE3-1D1E-CDAD-B2BE-3F8B5D135AFF": [
              {
                "uuid": "6BA22080-478E-D46C-22D1-7F5347202693",
                "name": "extractYAMLMetadata",
                "source": "private async extractYAMLMetadata(text: string, globalSchema: OutputSchema<any>): Promise<any | null> {\n    try {\n      const yaml = await import('js-yaml');\n\n      // Look for YAML code block\n      const yamlMatch = text.match(/```(?:yaml|yml)\\s*([\\s\\S]*?)\\s*```/);\n      if (yamlMatch) {\n        const parsed = yaml.load(yamlMatch[1]) as any;\n        const metadata: any = {};\n\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          if (parsed[fieldName] !== undefined) {\n            if (fieldSchema.type === 'object' && fieldSchema.nested) {\n              metadata[fieldName] = {};\n              for (const [nestedName, nestedSchema] of Object.entries(fieldSchema.nested)) {\n                if (parsed[fieldName][nestedName] !== undefined) {\n                  metadata[fieldName][nestedName] = this.convertValue(parsed[fieldName][nestedName], nestedSchema);\n                }\n              }\n            } else {\n              metadata[fieldName] = this.convertValue(parsed[fieldName], fieldSchema);\n            }\n          }\n        }\n\n        return Object.keys(metadata).length > 0 ? metadata : null;\n      }\n    } catch (err) {\n      console.warn('Failed to extract YAML metadata:', err);\n    }\n    return null;\n  }"
              },
              {
                "uuid": "1B67218B-90D9-B599-794C-F12C933659C1",
                "name": "packBatches",
                "source": "private packBatches<T>(\n    items: T[],\n    config: LLMStructuredCallConfig<T, any>\n  ): Batch<T>[] {\n    const tokenBudget = config.tokenBudget || 8000;\n    const batchSize = config.batchSize || 20;\n    const estimatedResponseTokens = this.estimateResponseSize(config.outputSchema);\n    const baseOverhead = 500; // System prompt, instructions, etc.\n\n    const batches: Batch<T>[] = [];\n    let currentBatch: T[] = [];\n    let currentTokens = baseOverhead;\n\n    for (const item of items) {\n      const itemTokens = this.estimateItemTokens(item, config);\n      const wouldExceed = currentTokens + itemTokens + estimatedResponseTokens > tokenBudget;\n\n      if (wouldExceed && currentBatch.length > 0) {\n        batches.push({ items: currentBatch, tokenEstimate: currentTokens });\n        currentBatch = [];\n        currentTokens = baseOverhead;\n      }\n\n      currentBatch.push(item);\n      currentTokens += itemTokens;\n\n      if (currentBatch.length >= batchSize) {\n        batches.push({ items: currentBatch, tokenEstimate: currentTokens });\n        currentBatch = [];\n        currentTokens = baseOverhead;\n      }\n    }\n\n    if (currentBatch.length > 0) {\n      batches.push({ items: currentBatch, tokenEstimate: currentTokens });\n    }\n\n    return batches;\n  }"
              },
              {
                "uuid": "E77DC05C-0D58-82FA-6113-10A8D489EC47",
                "name": "requestGlobalToolCalls",
                "source": "private async requestGlobalToolCalls<TInput>(\n    items: TInput[],\n    config: LLMStructuredCallConfig<TInput, any>\n  ): Promise<{ tool_calls?: ToolCallRequest[] }> {\n    // Build prompt with all items\n    const prompt = this.buildGlobalToolCallPrompt(items, config);\n\n    // Call with XML schema for tool calls\n    const result = await this.executeLLMBatch<any, { tool_calls?: ToolCallRequest[] }>(\n      [{ items }],\n      {\n        inputFields: ['items'],\n        systemPrompt: this.buildSystemPromptWithTools(config.tools!),\n        userTask: prompt,\n        outputSchema: {\n          tool_calls: {\n            type: 'array',\n            description: 'Tools to call before processing batch (leave empty if you have enough information)',\n            required: false,\n            items: {\n              type: 'object',\n              description: 'Tool call',\n              properties: {\n                tool_name: {\n                  type: 'string',\n                  description: 'Name of the tool to call',\n                  required: true,\n                },\n                arguments: {\n                  type: 'object',\n                  description: 'Tool arguments as key-value pairs',\n                  required: true,\n                },\n              },\n            },\n          },\n        },\n        outputFormat: 'xml',\n        llmProvider: config.llmProvider,\n        batchSize: 1,\n      }\n    );\n\n    const response = Array.isArray(result) ? result[0] : result.items[0];\n    return response || { tool_calls: [] };\n  }"
              },
              {
                "uuid": "7F4F39AA-B250-06FE-F60B-19CC45881886",
                "name": "formatArrayOrValue",
                "source": "private formatArrayOrValue(value: any, field: EntityField, maxLength: number): string | null {\n    if (Array.isArray(value)) {\n      const items = value.slice(0, 5); // Limit array items\n      return items.map(v => this.formatValueWithLength(v, maxLength)).join(', ');\n    }\n\n    if (typeof value === 'object' && value !== null) {\n      // Handle structured summaries\n      return this.formatStructuredSummary(value);\n    }\n\n    return this.formatValueWithLength(value, maxLength);\n  }"
              },
              {
                "uuid": "DBFB7F15-434F-54D7-4633-412C9B39624E",
                "name": "estimateCost",
                "source": "private estimateCost(\n    promptTokens: number,\n    responseTokens: number,\n    provider: string,\n    model?: string\n  ): number {\n    // Simplified cost estimation (USD per 1M tokens)\n    // These are rough estimates - actual pricing varies\n    const pricing: Record<string, { input: number; output: number }> = {\n      'gemini': { input: 0.35, output: 1.05 }, // Gemini 1.5 Pro\n      'openai': { input: 10, output: 30 }, // GPT-4 Turbo\n      'anthropic': { input: 3, output: 15 }, // Claude 3.5 Sonnet\n      'ollama': { input: 0, output: 0 }, // Local, free\n    };\n\n    const rates = pricing[provider.toLowerCase()] || { input: 1, output: 3 };\n\n    const inputCost = (promptTokens / 1_000_000) * rates.input;\n    const outputCost = (responseTokens / 1_000_000) * rates.output;\n\n    return inputCost + outputCost;\n  }"
              },
              {
                "uuid": "C65DE98F-59E9-BC0F-F4A3-E166D755EF12",
                "name": "executeBatchWithPerItemTools",
                "source": "private async executeBatchWithPerItemTools<TInput, TOutput>(\n    items: TInput[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): Promise<(TInput & TOutput)[] | LLMBatchResult<TInput, TOutput, any>> {\n    const maxIterations = config.maxIterationsPerItem ?? 3;\n    console.log(`\\nüîÅ Per-item tool calling: Processing ${items.length} items (max ${maxIterations} iterations each)...`);\n\n    const results: (TInput & TOutput)[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      console.log(`\\n   Item ${i + 1}/${items.length}:`);\n      const result = await this.processItemWithTools(items[i], config, maxIterations);\n      results.push(result);\n    }\n\n    console.log(`\\n‚úÖ All items processed`);\n\n    // Return in same format as executeLLMBatch\n    if (config.globalSchema) {\n      return {\n        items: results,\n        globalMetadata: undefined, // No global metadata in per-item mode\n      };\n    }\n\n    return results;\n  }"
              },
              {
                "uuid": "5465FF6B-782E-E449-A7C1-4927B1BA33DD",
                "name": "shouldSkipField",
                "source": "private shouldSkipField(fieldName: string, value: unknown): boolean {\n    const lower = fieldName.toLowerCase();\n    if (lower.includes('embedding') || lower.includes('vector')) return true;\n\n    if (Array.isArray(value)) {\n      if (value.length === 0) return false;\n      return value.every(item => typeof item === 'number');\n    }\n\n    return false;\n  }"
              },
              {
                "uuid": "1C9316F1-2B47-BFEA-B4C8-ADDB51CAB8CA",
                "name": "executeReranking",
                "source": "async executeReranking<T>(\n    items: T[],\n    config: Partial<LLMStructuredCallConfig<T, ItemEvaluation>> & {\n      userQuestion: string;\n      withFeedback?: boolean;\n      getItemId?: (item: T, index: number) => string;\n    }\n  ): Promise<{ evaluations: ItemEvaluation[]; queryFeedback?: QueryFeedback }> {\n    // Add reranking-specific prompts\n    const rerankConfig: LLMStructuredCallConfig<T, ItemEvaluation> = {\n      ...config,\n      systemPrompt: config.systemPrompt || `You are ranking ${config.entityContext?.displayName || 'items'} for relevance.`,\n      userTask: `User question: \"${config.userQuestion}\"`,\n      outputSchema: {\n        id: {\n          type: 'string',\n          description: 'Item ID from the input',\n          required: true\n        },\n        score: {\n          type: 'number',\n          description: 'Relevance score from 0.0 to 1.0',\n          required: true,\n          min: 0,\n          max: 1\n        },\n        reasoning: {\n          type: 'string',\n          description: 'Specific explanation referencing both the question and item details',\n          required: true\n        },\n        relevant: {\n          type: 'boolean',\n          description: 'Whether the item is relevant to the question',\n          default: true\n        }\n      },\n      outputFormat: 'xml'\n    };\n\n    // Add globalSchema for feedback if requested\n    if (config.withFeedback) {\n      rerankConfig.globalSchema = {\n        feedback: {\n          type: 'object',\n          description: 'Query quality feedback and suggestions',\n          required: false,\n          nested: {\n            quality: {\n              type: 'string',\n              description: 'Query quality: excellent, good, insufficient, or poor',\n              required: true\n            },\n            suggestions: {\n              type: 'array',\n              description: 'Array of suggestion objects with type and description',\n              required: false\n            }\n          }\n        }\n      };\n    }\n\n    // Execute LLM batch\n    const result = await this.executeLLMBatch<T, ItemEvaluation, { feedback?: QueryFeedback }>(items, rerankConfig);\n\n    // Handle both return formats (backward compat)\n    const isArrayResult = Array.isArray(result);\n    const itemResults = isArrayResult ? result : result.items;\n    const globalMetadata = isArrayResult ? undefined : result.globalMetadata;\n\n    // Extract evaluations\n    const evaluations: ItemEvaluation[] = itemResults.map((itemResult, index) => {\n      const itemId = config.getItemId ? config.getItemId(items[index], index) : String(index);\n      return {\n        id: itemResult.id || itemId,\n        score: itemResult.score,\n        reasoning: itemResult.reasoning,\n        relevant: itemResult.relevant\n      };\n    });\n\n    // Extract query feedback from global metadata\n    const queryFeedback = globalMetadata?.feedback as QueryFeedback | undefined;\n\n    return { evaluations, queryFeedback };\n  }"
              },
              {
                "uuid": "7615DE31-1FDC-3EC0-5843-BA4ED4CF1F96",
                "name": "generateEmbeddings",
                "source": "async generateEmbeddings<T>(\n    items: T[],\n    config: EmbeddingGenerationConfig\n  ): Promise<(T & { [key: string]: number[] })[]> {\n    const targetField = config.targetField || 'generated_embedding';\n\n    // Get embedding provider\n    const provider = this.getEmbeddingProvider(config.provider);\n\n    // Build texts to embed\n    const texts = items.map(item => this.buildEmbeddingText(item, config));\n\n    // Generate embeddings in batches\n    const batchSize = config.batchSize || 20;\n    const embeddings: number[][] = [];\n\n    for (let i = 0; i < texts.length; i += batchSize) {\n      const batch = texts.slice(i, i + batchSize);\n      const batchEmbeddings = await provider.embedBatch(batch);\n      embeddings.push(...batchEmbeddings);\n    }\n\n    // Merge embeddings with items\n    return items.map((item, index) => ({\n      ...item,\n      [targetField]: embeddings[index]\n    })) as any;\n  }"
              },
              {
                "uuid": "0A51D21B-34BA-66AA-EC2C-83F2A4F87B4D",
                "name": "getLLMProvider",
                "source": "private getLLMProvider(config?: LLMConfig): LLMProviderAdapter {\n    const provider = config?.provider || this.defaultLLMConfig?.provider || 'gemini';\n    const cacheKey = `${provider}:${config?.model || ''}`;\n\n    if (!this.llmProviders.has(cacheKey)) {\n      this.llmProviders.set(\n        cacheKey,\n        new LLMProviderAdapter({\n          provider,\n          model: config?.model,\n          temperature: config?.temperature,\n          maxTokens: config?.maxTokens\n        })\n      );\n    }\n\n    return this.llmProviders.get(cacheKey)!;\n  }"
              },
              {
                "uuid": "419CFA49-831C-BC5F-49CC-54DCD573F4FB",
                "name": "generateOutputInstructions",
                "source": "private generateOutputInstructions(\n    schema: OutputSchema<any>,\n    globalSchema?: OutputSchema<any>,\n    format: 'xml' | 'json' | 'yaml' | 'auto' = 'xml',\n    globalMetadataFormat?: 'xml' | 'json' | 'yaml'\n  ): string {\n    // Determine actual format to use\n    const itemsFormat = format === 'auto' ? 'xml' : format;\n    const metadataFormat = globalMetadataFormat || itemsFormat;\n\n    if (itemsFormat === 'json') {\n      return this.generateJSONInstructions(schema, globalSchema, metadataFormat);\n    } else if (itemsFormat === 'yaml') {\n      return this.generateYAMLInstructions(schema, globalSchema, metadataFormat);\n    } else {\n      return this.generateXMLInstructions(schema, globalSchema, metadataFormat);\n    }\n  }"
              },
              {
                "uuid": "D81863FB-B98E-D46B-DCBA-6E276DE09C92",
                "name": "truncate",
                "source": "private truncate(text: string, max: number): string {\n    if (text.length <= max) return text;\n    return text.slice(0, max - 3) + '...';\n  }"
              },
              {
                "uuid": "7FCEDB4E-4AE4-0149-F220-6C95349306AC",
                "name": "getFieldValue",
                "source": "private getFieldValue(entity: any, field: EntityField): unknown {\n    // Prefer summary if configured\n    if (field.preferSummary) {\n      const prefix = `${field.name}_summary_`;\n      const summaryFields = Object.keys(entity).filter(k => k.startsWith(prefix));\n\n      if (summaryFields.length > 0) {\n        const summary: any = {};\n        for (const key of summaryFields) {\n          const fieldName = key.substring(prefix.length);\n          if (fieldName === 'hash' || fieldName.endsWith('_at')) continue;\n\n          const value = entity[key];\n          if (typeof value === 'string' && value.includes(',')) {\n            summary[fieldName] = value.split(',').map(s => s.trim());\n          } else {\n            summary[fieldName] = value;\n          }\n        }\n\n        if (Object.keys(summary).length > 0) return summary;\n      }\n    }\n\n    return entity[field.name];\n  }"
              },
              {
                "uuid": "68AE9779-3554-6A86-4971-7A5E92FBB735",
                "name": "formatStructuredSummary",
                "source": "private formatStructuredSummary(summary: any): string {\n    const parts: string[] = [];\n\n    if (summary.purpose) parts.push(`Purpose: ${summary.purpose}`);\n    if (summary.operation && Array.isArray(summary.operation)) {\n      parts.push(`Operations: ${summary.operation.join('; ')}`);\n    }\n    if (summary.dependency && Array.isArray(summary.dependency)) {\n      parts.push(`Dependencies: ${summary.dependency.join(', ')}`);\n    }\n    if (summary.concept && Array.isArray(summary.concept)) {\n      parts.push(`Concepts: ${summary.concept.join(', ')}`);\n    }\n    if (summary.complexity) parts.push(`Complexity: ${summary.complexity}`);\n\n    return parts.join('\\n');\n  }"
              },
              {
                "uuid": "1ADB4793-CD09-B82D-EFB3-E0F607C1BBB6",
                "name": "getEmbeddingProvider",
                "source": "private getEmbeddingProvider(config?: { provider?: string; model?: string }): EmbeddingProviderAdapter {\n    const provider = config?.provider || this.defaultEmbeddingConfig?.provider || 'gemini';\n    const cacheKey = `${provider}:${config?.model || ''}`;\n\n    if (!this.embeddingProviders.has(cacheKey)) {\n      this.embeddingProviders.set(\n        cacheKey,\n        new EmbeddingProviderAdapter({\n          provider,\n          model: config?.model\n        })\n      );\n    }\n\n    return this.embeddingProviders.get(cacheKey)!;\n  }"
              },
              {
                "uuid": "234F601A-19B4-0A66-8C76-BA2F29824786",
                "name": "executeBatchWithGlobalTools",
                "source": "private async executeBatchWithGlobalTools<TInput, TOutput>(\n    items: TInput[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): Promise<(TInput & TOutput)[] | LLMBatchResult<TInput, TOutput, any>> {\n    console.log(`\\nüìä Global tool calling: Analyzing ${items.length} items...`);\n\n    // 1. Request global tool calls\n    const toolCallsResponse = await this.requestGlobalToolCalls(items, config);\n\n    // 2. Execute tools if requested\n    let toolResults: ToolExecutionResult[] = [];\n    if (toolCallsResponse.tool_calls && toolCallsResponse.tool_calls.length > 0) {\n      console.log(`   üîß Executing ${toolCallsResponse.tool_calls.length} tool(s)...`);\n      toolResults = await this.executeToolCalls(\n        toolCallsResponse.tool_calls,\n        config.toolExecutor\n      );\n\n      const successful = toolResults.filter(r => r.success).length;\n      console.log(`   ‚úÖ Tools executed: ${successful}/${toolResults.length} successful`);\n    } else {\n      console.log(`   ‚ÑπÔ∏è  No tool calls needed`);\n    }\n\n    // 3. Batch process with tool results\n    console.log(`\\nüì¶ Batch processing ${items.length} items with tool context...`);\n    return this.batchProcessWithToolResults(items, toolResults, config);\n  }"
              },
              {
                "uuid": "C73EAE9D-2193-03F4-E929-370DF1BF5438",
                "name": "formatItemsWithEntityContext",
                "source": "private formatItemsWithEntityContext<T>(\n    items: T[],\n    entityContext: EntityContext\n  ): string {\n    const DEFAULT_FIELD_MAX = 2500;\n    const DEFAULT_HEADER_MAX = 120;\n\n    return items.map((item, index) => {\n      const entity = item as any;\n      const lines: string[] = [];\n\n      // Render required fields in header\n      const requiredFields = entityContext.fields.filter(f => f.required);\n      const headerParts = requiredFields.map(field => {\n        const rawValue = entity[field.name];\n        if (this.shouldSkipField(field.name, rawValue)) {\n          return field.name;\n        }\n        const headerValue = this.formatValueWithLength(rawValue, DEFAULT_HEADER_MAX);\n        return headerValue ?? field.name;\n      });\n      lines.push(`[${index}] ${headerParts.join(' - ')}`);\n\n      // Render optional fields\n      const optionalFields = entityContext.fields.filter(f => !f.required);\n      for (const field of optionalFields) {\n        const value = this.getFieldValue(entity, field);\n        if (!value || this.shouldSkipField(field.name, value)) {\n          continue;\n        }\n\n        const label = field.label || field.name;\n        const printable = this.formatArrayOrValue(value, field, DEFAULT_FIELD_MAX);\n        if (printable) {\n          lines.push(`${label}: ${printable}`);\n        }\n      }\n\n      // Render enrichment fields (relationships)\n      for (const enrichment of entityContext.enrichments) {\n        const value = entity[enrichment.fieldName];\n        if (value && Array.isArray(value) && value.length > 0) {\n          const maxItems = enrichment.maxItems || 10;\n          const items = value.slice(0, maxItems);\n          lines.push(`${enrichment.label}: ${items.join(', ')}`);\n        }\n      }\n\n      lines.push(''); // Empty line between items\n      return lines.join('\\n');\n    }).join('\\n');\n  }"
              },
              {
                "uuid": "373CA4F9-DEC1-8435-E01F-51F5C7DFEBE1",
                "name": "buildEmbeddingText",
                "source": "private buildEmbeddingText<T>(item: T, config: EmbeddingGenerationConfig): string {\n    const parts: string[] = [];\n\n    // Add source fields\n    for (const fieldName of config.sourceFields) {\n      const value = (item as any)[fieldName];\n      if (value) {\n        parts.push(this.formatValue(value));\n      }\n    }\n\n    // Add relationship context if configured\n    if (config.includeRelationships) {\n      // TODO: Format relationships\n      // For now, placeholder\n    }\n\n    // Combine based on strategy\n    switch (config.combineStrategy) {\n      case 'weighted':\n        // TODO: Apply weights\n        return parts.join(' ');\n\n      case 'separate':\n        // TODO: Return separate embeddings per field\n        return parts.join(' ');\n\n      case 'concat':\n      default:\n        return parts.join(' ');\n    }\n  }"
              },
              {
                "uuid": "61292AAC-5C95-E465-4F15-4377937C972B",
                "name": "buildTaskWithToolResults",
                "source": "private buildTaskWithToolResults(originalTask: string, toolResults: ToolExecutionResult[]): string {\n    if (toolResults.length === 0) {\n      return originalTask;\n    }\n\n    const resultsStr = toolResults\n      .filter(r => r.success)\n      .map((r, i) => {\n        const resultStr = typeof r.result === 'object'\n          ? JSON.stringify(r.result, null, 2)\n          : String(r.result);\n        return `Tool ${i + 1}: ${r.tool_name}\\nResult: ${resultStr}`;\n      })\n      .join('\\n\\n');\n\n    return `${originalTask}\n\nTool Results Available:\n${resultsStr}\n\nUse these tool results to enhance your analysis of each item.`;\n  }"
              },
              {
                "uuid": "E4B9B5F8-FE2F-23E7-9853-90F6A6EF0630",
                "name": "estimateTokens",
                "source": "estimateTokens<T>(\n    items: T[],\n    config: LLMStructuredCallConfig<T, any>\n  ): {\n    totalPromptTokens: number;\n    totalResponseTokens: number;\n    estimatedCostUSD: number;\n    batchCount: number;\n    itemsPerBatch: number[];\n    provider: string;\n    model?: string;\n  } {\n    // Validate config first\n    this.validateLLMConfig(config);\n\n    // Pack items into batches (same logic as actual execution)\n    const batches = this.packBatches(items, config);\n\n    let totalPromptTokens = 0;\n    let totalResponseTokens = 0;\n\n    // Estimate tokens for each batch\n    for (const batch of batches) {\n      // Build actual prompt to get accurate estimate\n      const prompt = this.buildPrompt(batch.items, config);\n\n      // Estimate prompt tokens: 1 token ‚âà 4 characters (rough heuristic)\n      const promptTokens = Math.ceil(prompt.length / 4);\n      totalPromptTokens += promptTokens;\n\n      // Estimate response tokens based on output schema\n      const responseTokens = this.estimateResponseTokensForBatch(\n        batch.items.length,\n        config.outputSchema,\n        config.globalSchema\n      );\n      totalResponseTokens += responseTokens;\n    }\n\n    // Get provider info\n    const provider = config.llm?.provider || this.defaultLLMConfig?.provider || 'unknown';\n    const model = config.llm?.model || this.defaultLLMConfig?.model;\n\n    // Estimate cost based on provider/model\n    const estimatedCostUSD = this.estimateCost(\n      totalPromptTokens,\n      totalResponseTokens,\n      provider,\n      model\n    );\n\n    return {\n      totalPromptTokens,\n      totalResponseTokens,\n      estimatedCostUSD,\n      batchCount: batches.length,\n      itemsPerBatch: batches.map(b => b.items.length),\n      provider,\n      model\n    };\n  }"
              },
              {
                "uuid": "3A79CC34-2A20-369B-FE62-CA6DF641D062",
                "name": "generateJSONInstructions",
                "source": "private generateJSONInstructions(\n    schema: OutputSchema<any>,\n    globalSchema?: OutputSchema<any>,\n    globalFormat: 'xml' | 'json' | 'yaml' = 'json'\n  ): string {\n    const instructions: string[] = [\n      'You MUST respond with structured JSON in the following format:',\n      '',\n      '```json',\n      '{'\n    ];\n\n    if (globalSchema && globalFormat === 'json') {\n      // Include global metadata at root level\n      for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n        const required = fieldSchema.required ? ' (REQUIRED)' : '';\n        instructions.push(`  \"${fieldName}\": ${this.describeJSONType(fieldSchema)}${required},`);\n      }\n    }\n\n    instructions.push('  \"items\": [');\n    instructions.push('    {');\n\n    const schemaEntries = Object.entries(schema);\n    schemaEntries.forEach(([fieldName, fieldSchema], index) => {\n      const required = fieldSchema.required ? ' (REQUIRED)' : '';\n      const comma = index < schemaEntries.length - 1 ? ',' : '';\n      instructions.push(`      \"${fieldName}\": ${this.describeJSONType(fieldSchema)}${required}${comma}`);\n\n      if (fieldSchema.prompt) {\n        instructions.push(`      // ${fieldSchema.prompt}`);\n      }\n    });\n\n    instructions.push('    }');\n    instructions.push('  ]');\n    instructions.push('}');\n    instructions.push('```');\n\n    if (globalSchema && globalFormat !== 'json') {\n      instructions.push('');\n      if (globalFormat === 'xml') {\n        instructions.push('Additionally, include global metadata as XML:');\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          const required = fieldSchema.required ? ' (REQUIRED)' : '';\n          instructions.push(`<${fieldName}>${fieldSchema.description}${required}</${fieldName}>`);\n        }\n      } else {\n        instructions.push('Additionally, include global metadata as YAML:');\n        instructions.push('```yaml');\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          const required = fieldSchema.required ? ' (REQUIRED)' : '';\n          instructions.push(`${fieldName}: ${this.describeYAMLType(fieldSchema)}${required}`);\n        }\n        instructions.push('```');\n      }\n    }\n\n    return instructions.join('\\n');\n  }"
              },
              {
                "uuid": "55E04CE2-43C0-A79F-E0D8-241BC1DAC97F",
                "name": "formatValue",
                "source": "private formatValue(value: any): string {\n    if (typeof value === 'string') return value;\n    if (Array.isArray(value)) return value.join(', ');\n    if (typeof value === 'object') return JSON.stringify(value, null, 2);\n    return String(value);\n  }"
              },
              {
                "uuid": "906ACA1D-A4C5-05E7-03B4-92844194657E",
                "name": "parseJSONResponse",
                "source": "private parseJSONResponse<TOutput>(\n    jsonText: string,\n    schema: OutputSchema<TOutput>,\n    globalSchema?: OutputSchema<any>\n  ): { items: TOutput[]; globalMetadata?: any } {\n    const results: TOutput[] = [];\n    let globalMetadata: any = undefined;\n\n    try {\n      // Try to extract JSON from markdown code blocks\n      let cleanedText = jsonText.trim();\n      const jsonMatch = cleanedText.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n      if (jsonMatch) {\n        cleanedText = jsonMatch[1];\n      }\n\n      const parsed = JSON.parse(cleanedText);\n      const items = Array.isArray(parsed) ? parsed : (parsed.items || [parsed]);\n\n      for (const item of items) {\n        const output: any = {};\n\n        for (const [fieldName, fieldSchema] of Object.entries(schema) as [string, OutputFieldSchema][]) {\n          let value = item[fieldName];\n\n          if (value !== undefined) {\n            output[fieldName] = this.convertValue(value, fieldSchema);\n          } else if (fieldSchema.default !== undefined) {\n            output[fieldName] = fieldSchema.default;\n          } else if (fieldSchema.required) {\n            console.warn(`Required field \"${fieldName}\" missing in JSON response`);\n          }\n        }\n\n        results.push(output as TOutput);\n      }\n\n      // Parse global metadata if globalSchema provided\n      if (globalSchema && !Array.isArray(parsed)) {\n        globalMetadata = {};\n\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema) as [string, OutputFieldSchema][]) {\n          // Look for top-level field (not in items array)\n          const value = parsed[fieldName];\n\n          if (value !== undefined) {\n            if (fieldSchema.type === 'object' && fieldSchema.nested) {\n              // Parse nested object\n              globalMetadata[fieldName] = {};\n              for (const [nestedName, nestedSchema] of Object.entries(fieldSchema.nested) as [string, OutputFieldSchema][]) {\n                if (value[nestedName] !== undefined) {\n                  globalMetadata[fieldName][nestedName] = this.convertValue(value[nestedName], nestedSchema);\n                }\n              }\n            } else {\n              globalMetadata[fieldName] = this.convertValue(value, fieldSchema);\n            }\n          }\n        }\n      }\n    } catch (error: any) {\n      console.error('Failed to parse JSON response:', error.message);\n      console.error('JSON text:', jsonText);\n    }\n\n    return { items: results, globalMetadata };\n  }"
              },
              {
                "uuid": "D2EE458E-80D4-2103-6AB5-645F75F78460",
                "name": "executeToolCalls",
                "source": "private async executeToolCalls(\n    toolCalls: ToolCallRequest[],\n    toolExecutor?: ToolExecutor\n  ): Promise<ToolExecutionResult[]> {\n    if (toolExecutor) {\n      return toolExecutor.executeBatch(toolCalls);\n    }\n\n    // Default: mock execution\n    console.warn('   ‚ö†Ô∏è  No toolExecutor provided, using mock execution');\n    return toolCalls.map(tc => ({\n      tool_name: tc.tool_name,\n      success: true,\n      result: { mock: true, tool: tc.tool_name, arguments: tc.arguments },\n    }));\n  }"
              },
              {
                "uuid": "DB148F03-97D0-FEA5-5F61-F1F7082140EA",
                "name": "processItemWithTools",
                "source": "private async processItemWithTools<TInput, TOutput>(\n    item: TInput,\n    config: LLMStructuredCallConfig<TInput, TOutput>,\n    maxIterations: number\n  ): Promise<TInput & TOutput> {\n    let iteration = 0;\n    let toolContext: ToolExecutionResult[] = [];\n\n    while (iteration < maxIterations) {\n      iteration++;\n      console.log(`      Iteration ${iteration}...`);\n\n      // Call LLM with item + tool context\n      const response = await this.callLLMForItemWithTools(item, toolContext, config);\n\n      // Check if we have tool calls\n      if (response.tool_calls && response.tool_calls.length > 0) {\n        console.log(`      ‚Üí ${response.tool_calls.length} tool call(s)`);\n\n        // Execute tools\n        const toolResults = await this.executeToolCalls(\n          response.tool_calls,\n          config.toolExecutor\n        );\n\n        toolContext.push(...toolResults);\n      } else if (response.output) {\n        // We have final output\n        console.log(`      ‚Üí Final output`);\n        return { ...item, ...response.output } as TInput & TOutput;\n      } else {\n        throw new Error(`Item iteration ${iteration}: LLM returned neither tool_calls nor output`);\n      }\n    }\n\n    throw new Error(`Max iterations (${maxIterations}) reached without final output`);\n  }"
              },
              {
                "uuid": "2DB10575-1237-BD8B-92A9-68B57643A5C6",
                "name": "generateXMLInstructions",
                "source": "private generateXMLInstructions(\n    schema: OutputSchema<any>,\n    globalSchema?: OutputSchema<any>,\n    globalFormat: 'xml' | 'json' | 'yaml' = 'xml'\n  ): string {\n    const instructions: string[] = [\n      'You MUST respond with structured XML in the following format:',\n      '',\n      '<items>',\n      '  <item id=\"INDEX\">'\n    ];\n\n    for (const [fieldName, fieldSchema] of Object.entries(schema)) {\n      const required = fieldSchema.required ? ' (REQUIRED)' : '';\n      instructions.push(`    <${fieldName}>${fieldSchema.description}${required}</${fieldName}>`);\n\n      if (fieldSchema.prompt) {\n        instructions.push(`    <!-- ${fieldSchema.prompt} -->`);\n      }\n    }\n\n    instructions.push('  </item>');\n    instructions.push('</items>');\n\n    // Add global metadata instructions if provided\n    if (globalSchema) {\n      instructions.push('');\n      if (globalFormat === 'json') {\n        instructions.push('Additionally, include global metadata as JSON at the end:');\n        instructions.push('```json');\n        instructions.push('{');\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          const required = fieldSchema.required ? ' (REQUIRED)' : '';\n          instructions.push(`  \"${fieldName}\": ${this.describeJSONType(fieldSchema)}${required}`);\n        }\n        instructions.push('}');\n        instructions.push('```');\n      } else if (globalFormat === 'yaml') {\n        instructions.push('Additionally, include global metadata as YAML at the end:');\n        instructions.push('```yaml');\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          const required = fieldSchema.required ? ' (REQUIRED)' : '';\n          instructions.push(`${fieldName}: ${this.describeYAMLType(fieldSchema)}${required}`);\n        }\n        instructions.push('```');\n      } else {\n        instructions.push('');\n        instructions.push('Additionally, include these global metadata fields as sibling elements to <items>:');\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          const required = fieldSchema.required ? ' (REQUIRED)' : '';\n          instructions.push(`<${fieldName}>${fieldSchema.description}${required}</${fieldName}>`);\n        }\n      }\n    }\n\n    instructions.push('');\n    instructions.push('Replace INDEX with 0, 1, 2, etc. for each item.');\n\n    return instructions.join('\\n');\n  }"
              },
              {
                "uuid": "0B8DB57F-CB0B-4C6D-AE55-B08F4D1076AD",
                "name": "extractJSONMetadata",
                "source": "private extractJSONMetadata(text: string, globalSchema: OutputSchema<any>): any | null {\n    try {\n      // Look for JSON code block - specifically marked as json\n      const jsonMatch = text.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[1]);\n        const metadata: any = {};\n\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          if (parsed[fieldName] !== undefined) {\n            if (fieldSchema.type === 'object' && fieldSchema.nested) {\n              metadata[fieldName] = {};\n              for (const [nestedName, nestedSchema] of Object.entries(fieldSchema.nested)) {\n                if (parsed[fieldName][nestedName] !== undefined) {\n                  metadata[fieldName][nestedName] = this.convertValue(parsed[fieldName][nestedName], nestedSchema);\n                }\n              }\n            } else {\n              metadata[fieldName] = this.convertValue(parsed[fieldName], fieldSchema);\n            }\n          }\n        }\n\n        return Object.keys(metadata).length > 0 ? metadata : null;\n      }\n    } catch (err) {\n      console.warn('Failed to extract JSON metadata:', err);\n    }\n    return null;\n  }"
              },
              {
                "uuid": "1C120EA3-698A-1FC7-9D98-A3FF9FBC1F72",
                "name": "callLLMForItemWithTools",
                "source": "private async callLLMForItemWithTools<TInput, TOutput>(\n    item: TInput,\n    toolContext: ToolExecutionResult[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): Promise<{ output?: TOutput; tool_calls?: ToolCallRequest[] }> {\n    // Build task with tool context\n    const taskWithContext = toolContext.length > 0\n      ? this.buildTaskWithToolResults(config.userTask ?? '', toolContext)\n      : config.userTask ?? '';\n\n    // Create combined schema: either output OR tool_calls\n    const combinedSchema: any = {\n      ...config.outputSchema,\n      tool_calls: {\n        type: 'array',\n        description: 'Tools to call if you need more information. Leave an empty array if you can provide the final output.',\n        required: false,\n        items: {\n          type: 'object',\n          properties: {\n            tool_name: { type: 'string', required: true },\n            arguments: { type: 'object', required: true },\n          },\n        },\n      },\n    };\n\n    // Call LLM\n    const { customMerge, tools, toolMode, maxIterationsPerItem, toolChoice, useNativeToolCalling, toolExecutor, ...restConfig } = config;\n    const result = await this.executeLLMBatch<TInput, TOutput & { tool_calls?: ToolCallRequest[] }>(\n      [item],\n      {\n        ...restConfig,\n        userTask: taskWithContext,\n        outputSchema: combinedSchema,\n        systemPrompt: config.tools && config.tools.length > 0\n          ? this.buildSystemPromptWithTools(config.tools)\n          : config.systemPrompt,\n      }\n    );\n\n    const response = Array.isArray(result) ? result[0] : result.items[0];\n\n    // Debug logging\n    console.log('      [DEBUG] Raw response:', JSON.stringify(response, null, 2).substring(0, 500));\n\n    // Separate output from tool_calls\n    const { tool_calls, ...output } = response as any;\n\n    // Filter and validate tool_calls\n    const validToolCalls: ToolCallRequest[] = [];\n    if (tool_calls && Array.isArray(tool_calls)) {\n      for (const tc of tool_calls) {\n        // Skip empty strings or invalid objects\n        if (typeof tc === 'string' && tc.trim() === '') {\n          continue;\n        }\n        if (typeof tc === 'object' && tc.tool_name && tc.arguments) {\n          validToolCalls.push(tc);\n        }\n      }\n    }\n\n    // If we have valid tool_calls, return them\n    if (validToolCalls.length > 0) {\n      console.log('      [DEBUG] Returning tool calls:', validToolCalls);\n      return { tool_calls: validToolCalls };\n    }\n\n    // Otherwise return the output\n    console.log('      [DEBUG] Returning output (no valid tool calls)');\n    return { output: output as TOutput };\n  }"
              },
              {
                "uuid": "89A89773-35EF-CCA3-2B91-94C8C3F63AB4",
                "name": "mergeResults",
                "source": "private mergeResults<TInput, TOutput>(\n    inputs: TInput[],\n    outputs: TOutput[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): (TInput & TOutput)[] {\n    if (config.customMerge) {\n      return inputs.map((input, index) => config.customMerge!(input, outputs[index]));\n    }\n\n    switch (config.mergeStrategy) {\n      case 'replace':\n        return inputs.map((input, index) => ({ ...outputs[index], ...input } as any));\n      case 'append':\n      default:\n        return inputs.map((input, index) => ({ ...input, ...outputs[index] } as any));\n    }\n  }"
              },
              {
                "uuid": "EBB27167-9E1F-1179-9732-39EEFC2EBE30",
                "name": "generateYAMLInstructions",
                "source": "private generateYAMLInstructions(\n    schema: OutputSchema<any>,\n    globalSchema?: OutputSchema<any>,\n    globalFormat: 'xml' | 'json' | 'yaml' = 'yaml'\n  ): string {\n    const instructions: string[] = [\n      'You MUST respond with structured YAML in the following format:',\n      '',\n      '```yaml'\n    ];\n\n    if (globalSchema && globalFormat === 'yaml') {\n      // Include global metadata at root level\n      for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n        const required = fieldSchema.required ? ' (REQUIRED)' : '';\n        instructions.push(`${fieldName}: ${this.describeYAMLType(fieldSchema)}${required}`);\n      }\n      instructions.push('');\n    }\n\n    instructions.push('items:');\n    instructions.push('  - # First item');\n\n    for (const [fieldName, fieldSchema] of Object.entries(schema)) {\n      const required = fieldSchema.required ? ' (REQUIRED)' : '';\n      instructions.push(`    ${fieldName}: ${this.describeYAMLType(fieldSchema)}${required}`);\n\n      if (fieldSchema.prompt) {\n        instructions.push(`    # ${fieldSchema.prompt}`);\n      }\n    }\n\n    instructions.push('  - # Second item');\n    instructions.push('    ...');\n    instructions.push('```');\n\n    if (globalSchema && globalFormat !== 'yaml') {\n      instructions.push('');\n      if (globalFormat === 'xml') {\n        instructions.push('Additionally, include global metadata as XML:');\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          const required = fieldSchema.required ? ' (REQUIRED)' : '';\n          instructions.push(`<${fieldName}>${fieldSchema.description}${required}</${fieldName}>`);\n        }\n      } else {\n        instructions.push('Additionally, include global metadata as JSON:');\n        instructions.push('```json');\n        instructions.push('{');\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema)) {\n          const required = fieldSchema.required ? ' (REQUIRED)' : '';\n          instructions.push(`  \"${fieldName}\": ${this.describeJSONType(fieldSchema)}${required}`);\n        }\n        instructions.push('}');\n        instructions.push('```');\n      }\n    }\n\n    return instructions.join('\\n');\n  }"
              },
              {
                "uuid": "95573A9B-6566-2EB2-9628-F6CF0E6B67BE",
                "name": "executeLLMBatch",
                "source": "async executeLLMBatch<TInput, TOutput, TGlobal = any>(\n    items: TInput[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): Promise<(TInput & TOutput)[] | LLMBatchResult<TInput, TOutput, TGlobal>> {\n    // 1. Validate config\n    this.validateLLMConfig(config);\n\n    // Warn about less permissive formats\n    if (config.outputFormat === 'json' || config.outputFormat === 'yaml') {\n      console.warn(\n        `[StructuredLLMExecutor] Warning: Using ${config.outputFormat.toUpperCase()} format for structured generation. ` +\n        `This format is less permissive than XML and may fail more often if the LLM doesn't follow the exact format. ` +\n        `Consider using 'xml' (default) for more robust parsing.`\n      );\n    }\n    if (config.globalMetadataFormat === 'json' || config.globalMetadataFormat === 'yaml') {\n      console.warn(\n        `[StructuredLLMExecutor] Warning: Using ${config.globalMetadataFormat.toUpperCase()} format for global metadata. ` +\n        `This format is less permissive than XML and may fail more often if the LLM doesn't follow the exact format. ` +\n        `Consider using 'xml' (default) for more robust parsing.`\n      );\n    }\n\n    // 2. Pack items into optimal batches\n    const batches = this.packBatches(items, config);\n    console.log(\n      `[StructuredLLMExecutor] üì¶ Batching: ${items.length} items ‚Üí ${batches.length} batch(es) | ` +\n      `Items per batch: [${batches.map(b => b.items.length).join(', ')}] | ` +\n      `Parallel: ${config.parallel || 5}`\n    );\n\n    // 3. Execute batches in parallel\n    const responses = await this.executeParallelLLM(batches, config);\n\n    // 4. Parse outputs\n    const { items: parsedItems, globalMetadata } = await this.parseOutputs(\n      responses,\n      config.outputSchema,\n      config.globalSchema,\n      config.globalMetadataFormat\n    );\n\n    // 5. Merge with inputs\n    const mergedItems = this.mergeResults(items, parsedItems, config);\n\n    // 6. Return based on whether globalSchema was requested\n    if (config.globalSchema && globalMetadata !== undefined) {\n      return { items: mergedItems, globalMetadata } as LLMBatchResult<TInput, TOutput, TGlobal>;\n    }\n\n    // Backward compatible: return items directly if no globalSchema\n    return mergedItems as (TInput & TOutput)[];\n  }"
              },
              {
                "uuid": "C808184D-9EF0-EE60-B995-1D78899562C8",
                "name": "executeSingleLLMBatch",
                "source": "private async executeSingleLLMBatch<T>(\n    batch: Batch<T>,\n    config: LLMStructuredCallConfig<T, any>\n  ): Promise<LLMResponse> {\n    // Build prompt\n    const prompt = this.buildPrompt(batch.items, config);\n\n    // Log prompt if requested\n    if (config.logPrompts) {\n      await this.logContent('PROMPT', prompt, config.logPrompts);\n    }\n\n    let response: string;\n\n    // Use LLMProvider if provided (backward compat with LLMReranker)\n    if (config.llmProvider) {\n      response = await config.llmProvider.generateContent(prompt);\n    } else {\n      // Otherwise use LLMProviderAdapter (LlamaIndex)\n      const provider = this.getLLMProvider(config.llm);\n      response = await provider.generate(prompt);\n    }\n\n    // Log response if requested\n    if (config.logResponses) {\n      await this.logContent('RESPONSE', response, config.logResponses);\n    }\n\n    // Determine response format\n    let format: 'json' | 'xml' | 'yaml' = 'xml';\n    if (config.outputFormat === 'json') {\n      format = 'json';\n    } else if (config.outputFormat === 'yaml') {\n      format = 'yaml';\n    }\n\n    return {\n      text: response,\n      format\n    };\n  }"
              },
              {
                "uuid": "92471315-5736-6B15-8E7B-2D29F36C2D70",
                "name": "parseYAMLResponse",
                "source": "private async parseYAMLResponse<TOutput>(\n    yamlText: string,\n    schema: OutputSchema<TOutput>,\n    globalSchema?: OutputSchema<any>\n  ): Promise<{ items: TOutput[]; globalMetadata?: any }> {\n    const results: TOutput[] = [];\n    let globalMetadata: any = undefined;\n\n    try {\n      // Import yaml dynamically\n      const yaml = await import('js-yaml');\n\n      // Try to extract YAML from markdown code blocks\n      let cleanedText = yamlText.trim();\n      const yamlMatch = cleanedText.match(/```(?:yaml|yml)\\s*([\\s\\S]*?)\\s*```/);\n      if (yamlMatch) {\n        cleanedText = yamlMatch[1];\n      }\n\n      const parsed = yaml.load(cleanedText) as any;\n\n      // Extract items array\n      const items = Array.isArray(parsed) ? parsed : (parsed.items || [parsed]);\n\n      // Parse items\n      for (const item of items) {\n        const output: any = {};\n\n        for (const [fieldName, fieldSchema] of Object.entries(schema) as [string, OutputFieldSchema][]) {\n          const value = item[fieldName];\n\n          if (value !== undefined) {\n            output[fieldName] = this.convertValue(value, fieldSchema);\n          } else if (fieldSchema.default !== undefined) {\n            output[fieldName] = fieldSchema.default;\n          } else if (fieldSchema.required) {\n            console.warn(`Required field \"${fieldName}\" missing in YAML response`);\n          }\n        }\n\n        results.push(output as TOutput);\n      }\n\n      // Parse global metadata if globalSchema provided\n      if (globalSchema && !Array.isArray(parsed)) {\n        globalMetadata = {};\n\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema) as [string, OutputFieldSchema][]) {\n          const value = parsed[fieldName];\n\n          if (value !== undefined) {\n            if (fieldSchema.type === 'object' && fieldSchema.nested) {\n              // Parse nested object\n              globalMetadata[fieldName] = {};\n              for (const [nestedName, nestedSchema] of Object.entries(fieldSchema.nested) as [string, OutputFieldSchema][]) {\n                if (value[nestedName] !== undefined) {\n                  globalMetadata[fieldName][nestedName] = this.convertValue(value[nestedName], nestedSchema);\n                }\n              }\n            } else {\n              globalMetadata[fieldName] = this.convertValue(value, fieldSchema);\n            }\n          }\n        }\n      }\n    } catch (error: any) {\n      console.error('Failed to parse YAML response:', error.message);\n      console.error('YAML text:', yamlText);\n    }\n\n    return { items: results, globalMetadata };\n  }"
              },
              {
                "uuid": "4663B93F-C748-6F93-61AB-4E2D3A15142D",
                "name": "buildPrompt",
                "source": "private buildPrompt<T>(\n    items: T[],\n    config: LLMStructuredCallConfig<T, any>\n  ): string {\n    const parts: string[] = [];\n\n    // System context\n    if (config.systemPrompt) {\n      parts.push(config.systemPrompt);\n      parts.push('');\n    }\n\n    // User task\n    if (config.userTask) {\n      parts.push('## Task');\n      parts.push(config.userTask);\n      parts.push('');\n    }\n\n    // Context data\n    if (config.contextData) {\n      parts.push('## Context');\n      parts.push(JSON.stringify(config.contextData, null, 2));\n      parts.push('');\n    }\n\n    // Items to analyze\n    parts.push(`## Items to Analyze (${items.length} total)`);\n    parts.push('');\n    parts.push(this.formatItems(items, config));\n    parts.push('');\n\n    // Output instructions\n    parts.push('## Required Output Format');\n    parts.push(this.generateOutputInstructions(\n      config.outputSchema,\n      config.globalSchema,\n      config.outputFormat || 'xml',\n      config.globalMetadataFormat\n    ));\n    parts.push('');\n\n    // Additional instructions\n    if (config.instructions) {\n      parts.push('## Additional Instructions');\n      parts.push(config.instructions);\n      parts.push('');\n    }\n\n    return parts.join('\\n');\n  }"
              },
              {
                "uuid": "D616A090-3072-398D-6191-2CA03C6A2810",
                "name": "buildSystemPromptWithTools",
                "source": "private buildSystemPromptWithTools(tools: ToolDefinition[]): string {\n    const toolsDesc = tools\n      .map(\n        t => `- ${t.function.name}: ${t.function.description}\n  Parameters: ${JSON.stringify(t.function.parameters, null, 2)}`\n      )\n      .join('\\n\\n');\n\n    return `You are an AI assistant with access to tools.\n\nAvailable tools:\n${toolsDesc}\n\nUse tools when you need additional information to complete the task.\nCall tools strategically - only when the information is truly needed.`;\n  }"
              },
              {
                "uuid": "617DFC82-19FE-FC99-AC0A-3AB9EC89E778",
                "name": "logContent",
                "source": "private async logContent(label: string, content: string, logTo: boolean | string): Promise<void> {\n    const timestamp = new Date().toISOString();\n    const separator = '='.repeat(80);\n    const logMessage = `\\n${separator}\\n${label} @ ${timestamp}\\n${separator}\\n${content}\\n${separator}\\n`;\n\n    if (logTo === true) {\n      // Log to console\n      console.log(logMessage);\n    } else if (typeof logTo === 'string') {\n      // Log to file\n      const fs = await import('fs');\n      const path = await import('path');\n\n      // Ensure directory exists\n      const dir = path.dirname(logTo);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      // Append to file\n      fs.appendFileSync(logTo, logMessage);\n    }\n  }"
              },
              {
                "uuid": "957FF43D-DC28-AD1F-2C1C-16906A3F01B2",
                "name": "buildGlobalToolCallPrompt",
                "source": "private buildGlobalToolCallPrompt<TInput>(\n    items: TInput[],\n    config: LLMStructuredCallConfig<TInput, any>\n  ): string {\n    const inputFields = config.inputFields || [];\n\n    const itemsStr = items\n      .map((item, i) => {\n        const fields = inputFields\n          .map(field => {\n            const fieldName = typeof field === 'string' ? field : field.name;\n            const value = (item as any)[fieldName];\n            return `  ${fieldName}: ${this.formatValue(value)}`;\n          })\n          .join('\\n');\n        return `Item ${i + 1}:\\n${fields}`;\n      })\n      .join('\\n\\n');\n\n    return `${config.userTask || 'Analyze the following items'}\n\nItems to process (${items.length} total):\n${itemsStr}\n\nLook at ALL items and decide if you need to call any tools to gather additional information before processing them.\nIf you need tools, return the tool_calls array with the tools you want to call.\nIf you already have enough information to process all items, return an empty tool_calls array.`;\n  }"
              },
              {
                "uuid": "70EF8DDD-7754-5EB0-E702-B34ADB035D95",
                "name": "parseOutputs",
                "source": "private async parseOutputs<TOutput>(\n    responses: LLMResponse[],\n    schema: OutputSchema<TOutput>,\n    globalSchema?: OutputSchema<any>,\n    globalMetadataFormat?: 'json' | 'xml' | 'yaml'\n  ): Promise<{ items: TOutput[]; globalMetadata?: any }> {\n    const results: TOutput[] = [];\n    let globalMetadata: any = undefined;\n\n    for (const response of responses) {\n      if (response.format === 'json') {\n        // Parse JSON responses\n        // Only try to extract JSON global metadata if format matches or is unspecified\n        const shouldExtractJSONMetadata = !globalMetadataFormat || globalMetadataFormat === 'json';\n        const parsed = this.parseJSONResponse(\n          response.text,\n          schema,\n          shouldExtractJSONMetadata ? globalSchema : undefined\n        );\n        results.push(...parsed.items);\n        // Take first non-empty globalMetadata\n        if (!globalMetadata && parsed.globalMetadata) {\n          globalMetadata = parsed.globalMetadata;\n        }\n      } else if (response.format === 'yaml') {\n        // Parse YAML responses\n        // Only try to extract YAML global metadata if format matches or is unspecified\n        const shouldExtractYAMLMetadata = !globalMetadataFormat || globalMetadataFormat === 'yaml';\n        const parsed = await this.parseYAMLResponse(\n          response.text,\n          schema,\n          shouldExtractYAMLMetadata ? globalSchema : undefined\n        );\n        results.push(...parsed.items);\n        // Take first non-empty globalMetadata\n        if (!globalMetadata && parsed.globalMetadata) {\n          globalMetadata = parsed.globalMetadata;\n        }\n      } else {\n        // Parse XML responses (default)\n        // Only try to extract XML global metadata if format matches or is unspecified\n        const shouldExtractXMLMetadata = !globalMetadataFormat || globalMetadataFormat === 'xml';\n        const parsed = this.parseXMLResponse(\n          response.text,\n          schema,\n          shouldExtractXMLMetadata ? globalSchema : undefined\n        );\n        results.push(...parsed.items);\n        // Take first non-empty globalMetadata\n        if (!globalMetadata && parsed.globalMetadata) {\n          globalMetadata = parsed.globalMetadata;\n        }\n      }\n\n      // If globalSchema is provided and format differs from response format, try parsing global metadata separately\n      if (globalSchema && !globalMetadata && globalMetadataFormat && globalMetadataFormat !== response.format) {\n        if (globalMetadataFormat === 'json') {\n          // Try to extract JSON metadata from mixed response\n          const jsonMetadata = this.extractJSONMetadata(response.text, globalSchema);\n          if (jsonMetadata) {\n            globalMetadata = jsonMetadata;\n          }\n        } else if (globalMetadataFormat === 'yaml') {\n          // Try to extract YAML metadata from mixed response\n          const yamlMetadata = await this.extractYAMLMetadata(response.text, globalSchema);\n          if (yamlMetadata) {\n            globalMetadata = yamlMetadata;\n          }\n        }\n      }\n    }\n\n    return { items: results, globalMetadata };\n  }"
              },
              {
                "uuid": "5E2CEA72-7611-277B-C0D2-E703C648D8B3",
                "name": "validateLLMConfig",
                "source": "private validateLLMConfig<T>(config: LLMStructuredCallConfig<T, any>): void {\n    if (!config.inputFields && !config.entityContext) {\n      throw new Error('Either inputFields or entityContext is required');\n    }\n\n    if (!config.outputSchema || Object.keys(config.outputSchema).length === 0) {\n      throw new Error('outputSchema is required and must not be empty');\n    }\n\n    // Validate output schema\n    for (const [fieldName, fieldSchema] of Object.entries(config.outputSchema)) {\n      if (!fieldSchema.type) {\n        throw new Error(`Field ${fieldName} must have a type`);\n      }\n      if (!fieldSchema.description) {\n        throw new Error(`Field ${fieldName} must have a description`);\n      }\n    }\n  }"
              },
              {
                "uuid": "11E764E3-CCF8-595E-991E-990183F1BC91",
                "name": "estimateItemTokens",
                "source": "private estimateItemTokens<T>(\n    item: T,\n    config: LLMStructuredCallConfig<T, any>\n  ): number {\n    let tokens = 0;\n\n    // If using EntityContext, estimate based on entity fields\n    if (config.entityContext) {\n      for (const field of config.entityContext.fields) {\n        const value = (item as any)[field.name];\n        if (typeof value === 'string') {\n          tokens += Math.ceil(value.length / 4);\n        } else if (value) {\n          tokens += 50;\n        }\n      }\n      return tokens;\n    }\n\n    // Otherwise use inputFields\n    if (!config.inputFields) return 100; // Default estimate\n\n    for (const fieldConfig of config.inputFields) {\n      const fieldName = typeof fieldConfig === 'string' ? fieldConfig : fieldConfig.name;\n      const value = (item as any)[fieldName];\n\n      if (typeof value === 'string') {\n        tokens += Math.ceil(value.length / 4); // Rough estimate: 4 chars per token\n      } else if (value) {\n        tokens += 50; // Other types\n      }\n    }\n\n    return tokens;\n  }"
              },
              {
                "uuid": "785F92CB-19A6-677D-DA71-FFB181B9BE54",
                "name": "executeLLMBatchWithTools",
                "source": "async executeLLMBatchWithTools<TInput, TOutput>(\n    items: TInput[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): Promise<(TInput & TOutput)[] | LLMBatchResult<TInput, TOutput, any>> {\n    // If no tools provided, fallback to regular batch execution\n    if (!config.tools || config.tools.length === 0) {\n      return this.executeLLMBatch(items, config);\n    }\n\n    const toolMode = config.toolMode ?? 'global';\n\n    console.log(`\\nüîß [StructuredLLMExecutor] Tool calling enabled (${toolMode} mode)`);\n    console.log(`   Tools: ${config.tools.map(t => t.function.name).join(', ')}`);\n\n    if (toolMode === 'global') {\n      return this.executeBatchWithGlobalTools(items, config);\n    } else {\n      return this.executeBatchWithPerItemTools(items, config);\n    }\n  }"
              },
              {
                "uuid": "EA02F56B-EDF7-FB28-350D-628DE2413AE5",
                "name": "batchProcessWithToolResults",
                "source": "private async batchProcessWithToolResults<TInput, TOutput>(\n    items: TInput[],\n    toolResults: ToolExecutionResult[],\n    config: LLMStructuredCallConfig<TInput, TOutput>\n  ): Promise<(TInput & TOutput)[] | LLMBatchResult<TInput, TOutput, any>> {\n    // Build enhanced user task with tool results\n    const enhancedTask = this.buildTaskWithToolResults(config.userTask ?? '', toolResults);\n\n    // Execute regular batch with enhanced context\n    return this.executeLLMBatch(items, {\n      ...config,\n      userTask: enhancedTask,\n    });\n  }"
              },
              {
                "uuid": "5DEFE54C-30EC-8584-845D-F545035F7641",
                "name": "describeJSONType",
                "source": "private describeJSONType(fieldSchema: OutputFieldSchema): string {\n    switch (fieldSchema.type) {\n      case 'string':\n        return '\"string value\"';\n      case 'number':\n        return '123';\n      case 'boolean':\n        return 'true';\n      case 'array':\n        return '[]';\n      case 'object':\n        if (fieldSchema.nested) {\n          const nestedFields = Object.entries(fieldSchema.nested)\n            .map(([key, val]) => `\"${key}\": ${this.describeJSONType(val)}`)\n            .join(', ');\n          return `{ ${nestedFields} }`;\n        }\n        return '{}';\n      default:\n        return '\"value\"';\n    }\n  }"
              },
              {
                "uuid": "E10E7BF0-59AA-25CB-7155-D65C0A86C77B",
                "name": "executeParallelLLM",
                "source": "private async executeParallelLLM<T>(\n    batches: Batch<T>[],\n    config: LLMStructuredCallConfig<T, any>\n  ): Promise<LLMResponse[]> {\n    const parallel = config.parallel || 5;\n    const results: LLMResponse[] = [];\n\n    for (let i = 0; i < batches.length; i += parallel) {\n      const batchGroup = batches.slice(i, i + parallel);\n\n      console.log(\n        `[StructuredLLMExecutor] üöÄ Launching ${batchGroup.length} requests in parallel ` +\n        `(batch group ${Math.floor(i / parallel) + 1}/${Math.ceil(batches.length / parallel)})`\n      );\n\n      const groupResults = await Promise.all(\n        batchGroup.map(batch => this.executeSingleLLMBatch(batch, config))\n      );\n\n      results.push(...groupResults);\n    }\n\n    return results;\n  }"
              },
              {
                "uuid": "DA359C8A-4977-514C-F3DC-EF186D012154",
                "name": "describeYAMLType",
                "source": "private describeYAMLType(fieldSchema: OutputFieldSchema): string {\n    switch (fieldSchema.type) {\n      case 'string':\n        return '\"string value\"';\n      case 'number':\n        return '123';\n      case 'boolean':\n        return 'true';\n      case 'array':\n        return '[]';\n      case 'object':\n        if (fieldSchema.nested) {\n          return '{ nested object }';\n        }\n        return '{}';\n      default:\n        return '\"value\"';\n    }\n  }"
              },
              {
                "uuid": "0D10A15D-F9E3-4943-0CF4-3B64CC167568",
                "name": "estimateResponseSize",
                "source": "private estimateResponseSize(schema: OutputSchema<any>): number {\n    // Rough estimate: 100 tokens per field\n    return Object.keys(schema).length * 100;\n  }"
              },
              {
                "uuid": "494B443B-B5F9-EFE5-79F8-7764935304B3",
                "name": "constructor",
                "source": "constructor(\n    private defaultLLMConfig?: LLMConfig,\n    private defaultEmbeddingConfig?: { provider?: string; model?: string }\n  ) {}"
              },
              {
                "uuid": "F9651D22-AB93-BEF5-4CC4-E2E1A396F364",
                "name": "getTextContentFromElement",
                "source": "private getTextContentFromElement(element: any): string {\n    if (!element) return '';\n\n    // If element has direct text children, concatenate them\n    if (element.children) {\n      return element.children\n        .filter((c: any) => c.type === 'text')\n        .map((c: any) => c.content || '')\n        .join('')\n        .trim();\n    }\n\n    return '';\n  }"
              },
              {
                "uuid": "AAD27853-29B3-A43E-F912-9FF8EE34E88E",
                "name": "formatItems",
                "source": "private formatItems<T>(\n    items: T[],\n    config: LLMStructuredCallConfig<T, any>\n  ): string {\n    // Use EntityContext formatting if provided (same as LLMReranker)\n    if (config.entityContext) {\n      return this.formatItemsWithEntityContext(items, config.entityContext);\n    }\n\n    // Fall back to manual field config\n    if (!config.inputFields) {\n      throw new Error('Either entityContext or inputFields must be provided');\n    }\n\n    return items.map((item, index) => {\n      const lines: string[] = [`[Item ${index}]`];\n\n      for (const fieldConfig of config.inputFields!) {\n        const fieldName = typeof fieldConfig === 'string' ? fieldConfig : fieldConfig.name;\n        let value = (item as any)[fieldName];\n\n        // Apply transformations\n        if (typeof fieldConfig !== 'string') {\n          if (fieldConfig.transform) {\n            value = fieldConfig.transform(value);\n          }\n\n          if (fieldConfig.maxLength && typeof value === 'string') {\n            value = this.truncate(value, fieldConfig.maxLength);\n          }\n\n          if (fieldConfig.prompt) {\n            lines.push(`${fieldName} (${fieldConfig.prompt}):`);\n          } else {\n            lines.push(`${fieldName}:`);\n          }\n        } else {\n          lines.push(`${fieldName}:`);\n        }\n\n        lines.push(this.formatValue(value));\n      }\n\n      return lines.join('\\n');\n    }).join('\\n\\n');\n  }"
              },
              {
                "uuid": "4E4E4C53-BFCF-062A-EFBD-251F35AA9BC3",
                "name": "parseXMLResponse",
                "source": "private parseXMLResponse<TOutput>(\n    xmlText: string,\n    schema: OutputSchema<TOutput>,\n    globalSchema?: OutputSchema<any>\n  ): { items: TOutput[]; globalMetadata?: any } {\n    const results: TOutput[] = [];\n    let globalMetadata: any = undefined;\n\n    // Debug logging\n    if (process.env.DEBUG_XML === 'true') {\n      console.log('\\n=== RAW XML RESPONSE ===');\n      console.log(xmlText.substring(0, 2000));\n      console.log('========================\\n');\n    }\n\n    try {\n      const parser = new LuciformXMLParser(xmlText, { mode: 'luciform-permissive' });\n      const parseResult = parser.parse();\n\n      if (!parseResult.document?.root) {\n        console.warn('No XML root element found');\n        return { items: [], globalMetadata: undefined };\n      }\n\n      const root = parseResult.document.root;\n\n      // Extract items from <items> or <evaluations> root\n      const itemElements = root.children?.filter(\n        (child: any) => child.type === 'element' && child.name === 'item'\n      ) || [];\n\n      if (itemElements.length === 0) {\n        console.warn('No <item> elements found in XML response');\n        return { items: [], globalMetadata: undefined };\n      }\n\n      // Group items by ID (Gemini sometimes generates multiple <item> elements with same ID)\n      const itemsById = new Map<string, any>();\n\n      for (const itemEl of itemElements) {\n        const item = itemEl as any; // Cast to any for XML node access\n\n        // Get item ID from attributes\n        const itemId = item.attributes?.get?.('id') || item.attributes?.id || '0';\n\n        // Get or create output for this ID\n        if (!itemsById.has(itemId)) {\n          itemsById.set(itemId, {});\n        }\n        const output = itemsById.get(itemId);\n\n        // Map XML attributes/elements to output schema\n        for (const [fieldName, fieldSchema] of Object.entries(schema) as [string, OutputFieldSchema][]) {\n          // Skip if already extracted\n          if (output[fieldName] !== undefined) continue;\n\n          // Try attribute first, then child element\n          let value = item.attributes?.get?.(fieldName) || item.attributes?.[fieldName];\n\n          if (value === undefined && item.children) {\n            const childEl = item.children.find((c: any) => c.type === 'element' && c.name === fieldName);\n            if (childEl) {\n              // Extract text content from child elements\n              value = this.getTextContentFromElement(childEl);\n            }\n          }\n\n          if (value !== undefined) {\n            // Type conversion based on schema\n            output[fieldName] = this.convertValue(value, fieldSchema);\n          } else if (fieldSchema.default !== undefined) {\n            output[fieldName] = fieldSchema.default;\n          } else if (fieldSchema.required) {\n            console.warn(`Required field \"${fieldName}\" missing in XML response`);\n          }\n        }\n      }\n\n      // Convert map to array, sorted by ID\n      const sortedIds = Array.from(itemsById.keys()).sort((a, b) => {\n        const numA = parseInt(a, 10);\n        const numB = parseInt(b, 10);\n        return isNaN(numA) || isNaN(numB) ? a.localeCompare(b) : numA - numB;\n      });\n\n      for (const id of sortedIds) {\n        results.push(itemsById.get(id) as TOutput);\n      }\n\n      // Parse global metadata if globalSchema is provided\n      if (globalSchema && root.children) {\n        globalMetadata = {};\n\n        for (const [fieldName, fieldSchema] of Object.entries(globalSchema) as [string, OutputFieldSchema][]) {\n          // Look for child element with this name (not an <item>)\n          const globalEl = root.children.find(\n            (c: any) => c.type === 'element' && c.name === fieldName && c.name !== 'item'\n          );\n\n          if (globalEl) {\n            // Extract value from element\n            const value = this.getTextContentFromElement(globalEl);\n            if (value) {\n              globalMetadata[fieldName] = this.convertValue(value, fieldSchema);\n            }\n\n            // Also check for nested elements (like <suggestion> inside <feedback>)\n            if (globalEl.children) {\n              const nestedItems = globalEl.children.filter((c: any) => c.type === 'element');\n              if (nestedItems.length > 0 && fieldSchema.type === 'array') {\n                // Array of nested elements\n                globalMetadata[fieldName] = nestedItems.map((el: any) => {\n                  const obj: any = {};\n\n                  // Extract attributes\n                  if (el.attributes) {\n                    const attrs = el.attributes;\n                    if (attrs instanceof Map) {\n                      attrs.forEach((value, key) => {\n                        obj[key] = value;\n                      });\n                    } else {\n                      Object.assign(obj, attrs);\n                    }\n                  }\n\n                  // Extract text content\n                  const text = this.getTextContentFromElement(el);\n                  if (text && !obj.description) {\n                    obj.description = text;\n                  }\n\n                  return obj;\n                });\n              }\n            }\n          }\n        }\n      }\n    } catch (error: any) {\n      console.error('Failed to parse XML response:', error.message);\n      console.error('XML text:', xmlText);\n    }\n\n    return { items: results, globalMetadata };\n  }"
              },
              {
                "uuid": "EA73B57B-85FA-0C24-6E55-AD0B6030AA05",
                "name": "formatValueWithLength",
                "source": "private formatValueWithLength(value: any, maxLength: number): string {\n    if (typeof value === 'string') {\n      return this.truncate(value, maxLength);\n    }\n    if (Array.isArray(value)) return value.join(', ');\n    if (typeof value === 'object') return JSON.stringify(value);\n    return String(value);\n  }"
              },
              {
                "uuid": "52956317-5A62-BD8B-4B3D-2CBA6B764901",
                "name": "estimateResponseTokensForBatch",
                "source": "private estimateResponseTokensForBatch(\n    itemCount: number,\n    outputSchema: OutputSchema<any>,\n    globalSchema?: OutputSchema<any>\n  ): number {\n    // Estimate tokens per item based on schema fields\n    const fieldsPerItem = Object.keys(outputSchema).length;\n    const tokensPerField = 50; // Average tokens per field\n    const tokensPerItem = fieldsPerItem * tokensPerField;\n\n    // Add global schema if present\n    const globalTokens = globalSchema ? Object.keys(globalSchema).length * tokensPerField : 0;\n\n    // Total: items + global + XML overhead\n    return (itemCount * tokensPerItem) + globalTokens + 100;\n  }"
              },
              {
                "uuid": "E3A47965-1AB6-C9D6-9395-2E51B27A7F18",
                "name": "convertValue",
                "source": "private convertValue(value: any, schema: OutputFieldSchema): any {\n    switch (schema.type) {\n      case 'number':\n        return typeof value === 'number' ? value : parseFloat(value);\n\n      case 'boolean':\n        if (typeof value === 'boolean') return value;\n        if (typeof value === 'string') {\n          return value.toLowerCase() === 'true' || value === '1';\n        }\n        return Boolean(value);\n\n      case 'array':\n        if (Array.isArray(value)) return value;\n        if (typeof value === 'string') {\n          // Try to parse as JSON array or split by comma\n          try {\n            return JSON.parse(value);\n          } catch {\n            return value.split(',').map(s => s.trim());\n          }\n        }\n        return [value];\n\n      case 'object':\n        if (typeof value === 'object') return value;\n        if (typeof value === 'string') {\n          try {\n            return JSON.parse(value);\n          } catch {\n            return { value };\n          }\n        }\n        return value;\n\n      case 'string':\n      default:\n        return String(value);\n    }\n  }"
              }
            ]
          },
          "total_children": 53
        },
        "durationMs": 314
      }
    },
    {
      "timestamp": "2025-12-04T11:26:07.472Z",
      "type": "final_answer",
      "data": {
        "answer": "The StructuredLLMExecutor is a class that appears to be responsible for executing LLM (Language Model) calls in a structured manner. It includes functionality for extracting YAML metadata, packing batches of items for processing, requesting global tool calls, formatting arrays or values, estimating costs, executing batches with per-item or global tools, generating embeddings, and building prompts. It also handles parsing responses in JSON, XML, and YAML formats.",
        "confidence": "high"
      }
    }
  ],
  "toolsUsed": [
    "get_schema",
    "semantic_search",
    "get_entities_by_ids",
    "get_entity_by_id"
  ],
  "totalIterations": 0,
  "finalAnswer": "The StructuredLLMExecutor is a class that appears to be responsible for executing LLM (Language Model) calls in a structured manner. It includes functionality for extracting YAML metadata, packing batches of items for processing, requesting global tool calls, formatting arrays or values, estimating costs, executing batches with per-item or global tools, generating embeddings, and building prompts. It also handles parsing responses in JSON, XML, and YAML formats.",
  "endTime": "2025-12-04T11:26:07.472Z"
}