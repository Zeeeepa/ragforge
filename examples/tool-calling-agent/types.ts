/**
 * Generated types for packages
 * DO NOT EDIT - Generated by RagForge
 */

export interface Scope {
  name?: string;
  file?: string;
  source?: string;
  /** Count of DEFINED_IN relationships */
  definedInCount?: number;
  /** Count of CONSUMES relationships */
  consumesCount?: number;
  /** Count of HAS_PARENT relationships */
  hasParentCount?: number;
  /** Count of USES_LIBRARY relationships */
  usesLibraryCount?: number;
  /** Count of INHERITS_FROM relationships */
  inheritsFromCount?: number;
}

export interface ScopeFilter {
  name?: string | {
    equals?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    in?: string[];
  };
  file?: string | {
    equals?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    in?: string[];
  };
  source?: string | {
    equals?: string;
    contains?: string;
    startsWith?: string;
    endsWith?: string;
    in?: string[];
  };
}

/**
 * Input type for creating Scope entities
 * All fields are optional except 'uuid' which is required for uniqueness
 */
export interface ScopeCreate {
  name?: string;
  file?: string;
  source?: string;
}

/**
 * Input type for updating Scope entities
 * All fields are optional for partial updates
 * The unique field 'uuid' cannot be updated
 */
export interface ScopeUpdate {
  name?: string;
  file?: string;
  source?: string;
}

export interface SearchResult<T> {
  /** The entity that matched */
  entity: T;
  
  /** Overall relevance score (0-1) */
  score: number;
  
  /** Score breakdown by strategy */
  scoreBreakdown?: {
    semantic?: number;
    topology?: number;
    custom?: Record<string, number>;
  };
  
  /** Additional context */
  context?: {
    /** Related entities (if expand was used) */
    related?: any[];
    
    /** Text snippet highlighting match */
    snippet?: string;
  };
}

export interface QueryBuilder<T> {
  /** Filter by field values */
  where(filter: Partial<T>): QueryBuilder<T>;
  
  /** Semantic search by text */
  semantic(query: string, options?: { topK?: number }): QueryBuilder<T>;
  
  /** Expand to related entities via relationships */
  expand(relType: string, options?: { depth?: number }): QueryBuilder<T>;
  
  /** Apply reranking strategy */
  rerank(strategy: RerankingStrategy): QueryBuilder<T>;
  
  /** Limit number of results */
  limit(n: number): QueryBuilder<T>;
  
  /** Skip first n results */
  offset(n: number): QueryBuilder<T>;
  
  /** Execute query and return results */
  execute(): Promise<SearchResult<T>[]>;
  
  /** Explain query plan (for debugging) */
  explain(): Promise<QueryPlan>;
}

export type RerankingStrategy =
  | 'semantic'
  | { strategy: string; weights?: Record<string, number> };