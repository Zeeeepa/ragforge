import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');
const YAML_PATH = path.resolve(PROJECT_ROOT, 'ragforge.config.yaml');

export interface EmbeddingPipelineConfig {
  name: string;
  source: string;
  targetProperty: string;
  model?: string;
  dimension?: number;
  similarity?: 'cosine' | 'dot' | 'euclidean';
  preprocessors?: string[];
  includeFields?: string[];
  includeRelationships?: Array<{
    type: string;
    direction: 'outgoing' | 'incoming' | 'both';
    fields?: string[];
    depth?: number;
    maxItems?: number;
  }>;
  batchSize?: number;
  concurrency?: number;
  throttleMs?: number;
  maxRetries?: number;
  retryDelayMs?: number;
}

export interface EmbeddingEntityConfig {
  entity: string;
  pipelines: EmbeddingPipelineConfig[];
}

export interface EmbeddingsConfig {
  provider: string;
  defaults?: {
    model?: string;
    dimension?: number;
    similarity?: 'cosine' | 'dot' | 'euclidean';
  };
  entities: EmbeddingEntityConfig[];
}

function transformPipeline(pipeline: any): EmbeddingPipelineConfig | undefined {
  if (!pipeline) {
    return undefined;
  }

  return {
    name: pipeline.name,
    source: pipeline.source,
    targetProperty: pipeline.target_property ?? pipeline.targetProperty ?? 'embedding',
    model: pipeline.model,
    dimension: pipeline.dimension,
    similarity: pipeline.similarity,
    preprocessors: pipeline.preprocessors,
    includeFields: pipeline.include_fields,
    includeRelationships: pipeline.include_relationships
      ? pipeline.include_relationships.map((rel: any) => ({
          type: rel.type,
          direction: rel.direction,
          fields: rel.fields,
          depth: rel.depth,
          maxItems: rel.max_items ?? rel.maxItems
        }))
      : undefined,
    batchSize: pipeline.batch_size ?? pipeline.batchSize,
    concurrency: pipeline.concurrency,
    throttleMs: pipeline.throttle_ms ?? pipeline.throttleMs,
    maxRetries: pipeline.max_retries ?? pipeline.maxRetries,
    retryDelayMs: pipeline.retry_delay_ms ?? pipeline.retryDelayMs
  };
}

function transformEmbeddingsConfig(raw: any): EmbeddingsConfig {
  if (!raw) {
    throw new Error('Embeddings configuration missing from ragforge.config.yaml');
  }

  const entities = Array.isArray(raw.entities)
    ? raw.entities.map((entity: any) => ({
        entity: entity.entity,
        pipelines: Array.isArray(entity.pipelines)
          ? entity.pipelines
              .map(transformPipeline)
              .filter(Boolean) as EmbeddingPipelineConfig[]
          : []
      }))
    : [];

  return {
    provider: raw.provider,
    defaults: raw.defaults ? { ...raw.defaults } : undefined,
    entities
  };
}

function ensureConfigExists(): void {
  try {
    fs.accessSync(YAML_PATH, fs.constants.R_OK);
  } catch {
    throw new Error(
      `Cannot find ragforge.config.yaml next to generated artifacts.\n` +
      `Expected at: ${YAML_PATH}\n` +
      `Make sure you keep the config generated by RagForge alongside /generated.`
    );
  }
}

export function loadEmbeddingsConfig(): EmbeddingsConfig {
  ensureConfigExists();
  const yamlContent = fs.readFileSync(YAML_PATH, 'utf-8');
  const config = yaml.load(yamlContent) as any ?? {};
  return transformEmbeddingsConfig(config.embeddings);
}

export const EMBEDDINGS_CONFIG = loadEmbeddingsConfig();
