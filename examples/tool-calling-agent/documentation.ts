export const CLIENT_DOCUMENTATION = "# packages RAG Client - Agent Reference\n\nSimplified reference for LLM agent usage.\n\n## ‚≠ê Custom Methods\n\n### Semantic Search\n\n- **`scope().semanticSearchBySource(query, { topK?, minScore? })`**\n\n### Relationships\n\n- **`scope().whereFileName(targetName)`** - Filter scopes defined in the provided file\n- **`scope().withDefinedIn(depth?)`** - Expand DEFINED_IN relationships\n- **`scope().whereConsumesScope(targetName)`** - Filter scopes that consume the provided scope\n- **`scope().whereConsumedByScope(targetName)`** - Filter scopes consumed by the provided scope\n- **`scope().withConsumes(depth?)`** - Expand CONSUMES relationships\n- **`scope().whereParentScope(targetName)`** - Filter scopes with the provided parent scope\n- **`scope().withHasParent(depth?)`** - Expand HAS_PARENT relationships\n- **`scope().whereUsesLibrary(targetName)`** - Filter scopes that use the provided library\n- **`scope().withUsesLibrary(depth?)`** - Expand USES_LIBRARY relationships\n- **`scope().whereInheritsFrom(targetName)`** - Filter scopes that inherit from the provided scope\n- **`scope().withInheritsFrom(depth?)`** - Expand INHERITS_FROM relationships\n\n### Advanced\n\n- **`.llmRerank(question, { topK?, minScore? })`** - Rerank results using LLM reasoning\n- **`.executeWithMetadata()`** - Get pipeline execution details\n\n## üîß Core Query Methods\n\nAvailable on ALL entity builders:\n\n### Filtering\n- **`.where(filter: EntityFilter)`** - Complex filter with AND/OR logic\n- **`.limit(n: number)`** - Limit results to n items\n- **`.offset(n: number)`** - Skip first n items\n- **`.orderBy(field: string, direction: 'asc' | 'desc')`** - Sort results\n\n### Relationship Expansion\n- **`.expand(relType: string, { depth?, direction? })`** - Generic relationship traversal\n- **`.withXxx(depth?: number)`** - Expand specific relationships (auto-generated)\n\n### Execution\n- **`.execute()`** - Execute query and return SearchResult[]\n- **`.executeWithMetadata()`** - Execute with detailed pipeline information\n\n## üì¶ Result Structure\n\nAll queries return `SearchResult<T>[]`:\n\n```typescript\ninterface SearchResult<T> {\n  entity: T;              // The entity object\n  score: number;          // Relevance score (0-1)\n  scoreBreakdown?: {\n    semantic?: number;    // Semantic similarity score\n    llm?: number;         // LLM reranking score\n    llmReasoning?: string; // Why this result is relevant\n  };\n  context?: {\n    related?: RelatedEntity[]; // Connected nodes from withXxx() expansion\n  };\n}\n\ninterface RelatedEntity {\n  entity: T;\n  relationshipType: string;  // e.g., \"CONSUMES\", \"DEFINED_IN\"\n  depth: number;             // How many hops away\n}\n```\n\n**Accessing results:**\n```typescript\nconst results = await rag.scope()\n  .semanticSearchBySource('query', { topK: 10 })\n  .withDefinedIn(1)\n  .execute();\n\nresults.forEach(r => {\n  console.log(r.entity.name);          // Scope name\n  console.log(r.entity.name);        // name\n  console.log(r.score);                // Relevance score\n\n  // Access related entities from expansion\n  const related = r.context?.related?.filter(rel =>\n    rel.relationshipType === 'DEFINED_IN'\n  );\n});\n```\n\n## üìö Entity Reference\n\n### Scope (901 nodes)\n**Usage:** `rag.scope()`\n\n**Available Fields:**\n- `name: string`\n- `file: string`\n- `source: string`\n\n**Key Filters:**\n- `whereName(value)`\n- `whereFile(value)`\n- `whereSource(value)`\n- `semanticSearchBySource(query, options)` - Search by source\n- `withDefinedIn(depth?)` - Expand DEFINED_IN relationships\n- `withConsumes(depth?)` - Expand CONSUMES relationships\n- `withHasParent(depth?)` - Expand HAS_PARENT relationships\n\n## üé® Pipeline Patterns\n\n### Pattern 1: Broad ‚Üí Narrow (Recommended)\nStart with high topK, progressively filter and rerank:\n```typescript\nawait rag.scope()\n  .semanticSearchBySource('query', { topK: 100 })  // Cast wide net\n  .whereName('value')      // Focus\n  .llmRerank('specific question', { topK: 10 })  // Quality\n  .withDefinedIn(1)                            // Context\n  .execute();\n```\n\n### Pattern 2: Known Entry ‚Üí Expand\nStart with exact match, explore relationships:\n```typescript\n// Find specific entity\nawait rag.scope().whereName('TargetName').execute();\n\n// Map relationships\nawait rag.scope()\n  .whereName('TargetName')\n  .withDefinedIn(2)  // Get DEFINED_IN (2 levels)\n  .withConsumes(1)  // Get CONSUMES (1 level)\n  .execute();\n```\n\n### Decision Guidelines\n\n**When to stop:**\n- ‚úÖ Found 5-10 high-quality results (score > 0.8)\n- ‚úÖ Results directly answer the question\n- ‚úÖ Expanding more yields diminishing returns\n\n**When to continue:**\n- üîÑ Results on-topic but incomplete\n- üîÑ Scores mediocre (0.5-0.7) - try different query\n- üîÑ Only 1-2 results - query too narrow\n\n**When to pivot:**\n- üîÄ No results ‚Üí Broaden query or use relationships\n- üîÄ Too many (>50) ‚Üí Add filters or llmRerank\n- üîÄ Wrong results ‚Üí Different query or entity type\n\n## üìö Generated Examples\n\n### Semantic search by source\n*Find code scopes by semantic similarity to source*\n\n```typescript\nconsole.log('üîé Semantic search for: \"function printRootHelp...\"');\n  const results = await rag.scope()\n    .semanticSearchBySource('function printRootHelp...', { topK: 50 })\n    .execute();\n\n  console.log(`\\nFound ${results.length} results:`);\n  results.slice(0, 5).forEach(r => {\n    const entity = r.entity as any;\n    console.log('  - ' + entity.name + ' (score: ' + r.score.toFixed(3) + ')');\n  });\n  if (results.length > 5) {\n    console.log(`  ... and ${results.length - 5} more`);\n  }}\n\nexport { semanticSearchBySource };\n  // ... (14 more lines)\n```\n\n### Filter and expand by DEFINED_IN\n*Find code scopes related through DEFINED_IN*\n\n```typescript\nconsole.log('üîç Filtering by DEFINED_IN relationship...');\n  const filtered = await rag.scope()\n    .whereFileName('structured-llm-executor.ts')\n    .execute();\n\n  console.log(`\\nFound ${filtered.length} items with DEFINED_IN relationship:`);\n  filtered.slice(0, 5).forEach(r => {\n    const entity = r.entity as any;\n    console.log('  - ' + entity.name);\n  });\n  if (filtered.length > 5) {\n    console.log(`  ... and ${filtered.length - 5} more`);\n  }\n\n  console.log('\\nüîó Expanding relationships from \"CodeSourceAdapter\"...');\n  // ... (29 more lines)\n```\n\n### Filter and expand by CONSUMES\n*Find code scopes related through CONSUMES*\n\n```typescript\nconsole.log('üîç Filtering by CONSUMES relationship...');\n  const filtered = await rag.scope()\n    .whereConsumesScope('AddRelationshipConfig')\n    .execute();\n\n  console.log(`\\nFound ${filtered.length} items with CONSUMES relationship:`);\n  filtered.slice(0, 5).forEach(r => {\n    const entity = r.entity as any;\n    console.log('  - ' + entity.name);\n  });\n  if (filtered.length > 5) {\n    console.log(`  ... and ${filtered.length - 5} more`);\n  }\n\n  console.log('\\nüîó Expanding relationships from \"CodeSourceAdapter\"...');\n  // ... (29 more lines)\n```\n\n### Filter and expand by HAS_PARENT\n*Find code scopes related through HAS_PARENT*\n\n```typescript\nconsole.log('üîç Filtering by HAS_PARENT relationship...');\n  const filtered = await rag.scope()\n    .whereParentScope('CodeGenerator')\n    .execute();\n\n  console.log(`\\nFound ${filtered.length} items with HAS_PARENT relationship:`);\n  filtered.slice(0, 5).forEach(r => {\n    const entity = r.entity as any;\n    console.log('  - ' + entity.name);\n  });\n  if (filtered.length > 5) {\n    console.log(`  ... and ${filtered.length - 5} more`);\n  }\n\n  console.log('\\nüîó Expanding relationships from \"discoverFiles\"...');\n  // ... (29 more lines)\n```\n\n### Filter and expand by USES_LIBRARY\n*Find code scopes related through USES_LIBRARY*\n\n```typescript\nconsole.log('üîç Filtering by USES_LIBRARY relationship...');\n  const filtered = await rag.scope()\n    .whereUsesLibrary('path')\n    .execute();\n\n  console.log(`\\nFound ${filtered.length} items with USES_LIBRARY relationship:`);\n  filtered.slice(0, 5).forEach(r => {\n    const entity = r.entity as any;\n    console.log('  - ' + entity.name);\n  });\n  if (filtered.length > 5) {\n    console.log(`  ... and ${filtered.length - 5} more`);\n  }\n\n  console.log('\\nüîó Expanding relationships from \"CodeSourceAdapter\"...');\n  // ... (29 more lines)\n```\n\n### Filter and expand by INHERITS_FROM\n*Find code scopes related through INHERITS_FROM*\n\n```typescript\nconsole.log('üîç Filtering by INHERITS_FROM relationship...');\n  const filtered = await rag.scope()\n    .whereInheritsFrom('AddRelationshipConfig')\n    .execute();\n\n  console.log(`\\nFound ${filtered.length} items with INHERITS_FROM relationship:`);\n  filtered.slice(0, 5).forEach(r => {\n    const entity = r.entity as any;\n    console.log('  - ' + entity.name);\n  });\n  if (filtered.length > 5) {\n    console.log(`  ... and ${filtered.length - 5} more`);\n  }\n\n  console.log('\\nüîó Expanding relationships from \"CodeSourceAdapter\"...');\n  // ... (29 more lines)\n```\n\n### LLM reranking for better relevance\n*Find most relevant code scopes using AI reasoning*\n\n```typescript\nconsole.log('üîé Semantic search: \"function printRootHelp...\"');\n  console.log('ü§ñ Then reranking with LLM: \"find the most relevant code scopes around this semantic search: function printRootHelp(): void {...\"');\n\n  // NOTE: llmRerank() can be used after ANY operation that returns results.\n  // In this example, we use it after .semanticSearchBySource(), but you can also use it after:\n  //   - Filters: .whereFileName(), .whereName(), .whereFile()\n  //   - Relationships: .withDefinedIn(), .withConsumes()\n  //   - Or even directly without prior operations\n  const results = await rag.scope()\n    .semanticSearchBySource('function printRootHelp...', { topK: 50 })\n    .llmRerank('find the most relevant code scopes around this semantic search: function printRootHelp(): void {...', {\n      topK: 10,\n      minScore: 0.7\n    })\n    .execute();\n  // ... (32 more lines)\n```\n\n### Pipeline metadata and observability\n*Debug and optimize query pipelines*\n\n```typescript\nconst { results, metadata } = await rag.scope()\n    .semanticSearchBySource('function printRootHelp...', { topK: 50 })\n    .llmRerank('find code scopes related to: function printRootHelp...', { topK: 10 })\n    .executeWithMetadata();\n\n  console.log(`Pipeline executed in ${metadata.totalDuration}ms`);\n  console.log(`Final result count: ${metadata.finalCount}`);\n\n  metadata.operations.forEach((op, idx) => {\n    console.log(`\\n[${idx + 1}] ${op.type.toUpperCase()}`);\n    console.log(`  Duration: ${op.duration}ms`);\n    console.log(`  Results: ${op.inputCount} ‚Üí ${op.outputCount}`);\n\n    if (op.type === 'semantic' && op.metadata) {\n      console.log(`  Index: ${op.metadata.vectorIndex}`);\n  // ... (24 more lines)\n```\n\n### Complex multi-stage pipeline\n*Build sophisticated queries with multiple operations*\n\n```typescript\n// Multi-stage pipeline:\n  // 1. Semantic search (broad)\n  // 2. Filter (focus)\n  // 3. LLM rerank (quality)\n  // 4. Expand relationships (complete context)\n  // 5. Track metadata (observe)\n  const { results, metadata } = await rag.scope()\n    .semanticSearchBySource('function printRootHelp...', { topK: 100 })\n    .whereFileName('index.ts')\n    .llmRerank('find the most relevant code scopes', { topK: 20 })\n    .withDefinedIn(1)\n    .executeWithMetadata();\n\n  console.log(`\\nüéØ Pipeline Results`);\n  console.log(`Total time: ${metadata.totalDuration}ms`);\n  // ... (30 more lines)\n```\n\n### Conditional search strategy\n*Demonstrate decision-making based on result count and quality*\n\n```typescript\n// Initial broad search\n  let results = await rag.scope()\n    .semanticSearchBySource('query', { topK: 50 })\n    .execute();\n\n  console.log(`Found ${results.length} initial results`);\n\n  // Decision 1: Too few results? Broaden query\n  if (results.length < 5) {\n    console.log('Too few results, broadening query...');\n    results = await rag.scope()\n      .semanticSearchBySource('broader query terms', { topK: 50 })\n      .execute();\n  }\n\n  // ... (32 more lines)\n```\n\n### Breadth-first context exploration\n*Map local context by exploring 1-hop relationships*\n\n```typescript\n// Find entry point\n  const entry = await rag.scope()\n    .whereName('CodeSourceAdapter')\n    .execute();\n\n  if (entry.length === 0) {\n    console.log('Entry point not found');  }\n\n  // Breadth-first: Get immediate neighborhood\n  const context = await rag.scope()\n    .whereName('CodeSourceAdapter')\n    .withDefinedIn(1)\n    .withConsumes(1)\n    .withHasParent(1)\n    .execute();\n  // ... (24 more lines)\n```\n\n### Stopping criteria logic\n*Show decision logic for iterative search with quality thresholds*\n\n```typescript\nconst MAX_ITERATIONS = 3;\n  const TARGET_RESULTS = 5;\n  const MIN_SCORE = 0.8;\n\n  let allResults: any[] = [];\n  let iteration = 0;\n  let shouldContinue = true;\n\n  while (shouldContinue && iteration < MAX_ITERATIONS) {\n    iteration++;\n    console.log(`\\nIteration ${iteration}`);\n\n    // Progressive search strategy\n    const query = iteration === 1 ? 'initial query' : 'refined query';\n\n  // ... (40 more lines)\n```\n\n### CRUD operations with mutations\n*mutation, crud, create, update, delete, relationships*\n\n```typescript\nconsole.log('üìö Testing CRUD mutations\\n');\n\n  // 1. Create a new scope\n  console.log('1Ô∏è‚É£ Creating a new scope...');\n  const newScope: ScopeCreate = {\n    uuid: 'scope-test-001',\n    name: 'Sample name 1',\n    file: 'Sample file 2',\n    source: 'Sample source 3'\n  };\n\n  const createdScope = await rag.scopeMutations().create(newScope);\n  console.log('‚úÖ Scope created:', createdScope);\n  console.log();\n\n  // ... (48 more lines)\n```\n\n### Batch mutations\n*mutation, batch, createBatch, performance, transaction*\n\n```typescript\nconsole.log('üì¶ Testing batch mutations\\n');\n\n  // 1. Create multiple Scope entities in batch\n  console.log('1Ô∏è‚É£ Creating multiple scope entities in batch...');\n  const newScopes: ScopeCreate[] = [\n    {\n      uuid: 'scope-batch-001',\n      name: 'Sample Scope 1 name',\n      file: 'Sample Scope 1 file'\n    },\n    {\n      uuid: 'scope-batch-002',\n      name: 'Sample Scope 2 name',\n      file: 'Sample Scope 2 file'\n    },\n  // ... (41 more lines)\n```\n\n## Best Practices\n\n- Start broad with semantic search (topK: 50-100), then filter or rerank to top 5-10\n- Use `.llmRerank()` for complex reasoning queries\n- Chain operations: semantic ‚Üí filter ‚Üí llmRerank ‚Üí expand\n- Use `.executeWithMetadata()` to debug pipeline performance\n";
