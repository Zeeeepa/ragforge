# packages RAG Client

Version: 1.0.0

RAG-enabled codebase for packages

Generated by RagForge â€“ use this reference to drive both LLM agents and manual usage of the query builders.

## Quickstart

```typescript
import { createRagClient } from './client.js';

const rag = createRagClient({
  neo4j: {
    uri: process.env.NEO4J_URI!,
    username: process.env.NEO4J_USERNAME!,
    password: process.env.NEO4J_PASSWORD!
  }
});

const results = await rag.scope()
  .semantic('search text', { topK: 20 })
  .limit(10)
  .execute();
```

> Embeddings use Google Gemini (`@google/genai`) and require `GEMINI_API_KEY` in your environment.

## ðŸ“œ Available Scripts

This project includes auto-generated scripts for database management:

### `npm run setup`
**Complete setup workflow** - Run this for first-time setup:
1. Parses code from configured source paths
2. Ingests into Neo4j (creates Scope, File nodes)
3. Creates vector indexes
4. Generates embeddings

**When to use**: New project, or when you want a clean slate

### `npm run ingest`
**Incremental code ingestion** - Only re-processes changed files:
- Detects file changes using content hashing
- Only updates modified scopes
- Much faster than full re-ingestion

**When to use**: After code changes, for quick updates

**Example output**:
```
ðŸ” Analyzing changes...
   Created: 5
   Updated: 2
   Unchanged: 143
   Deleted: 0
```

### `npm run ingest:clean`
Clean database + fresh ingestion:
```bash
npm run ingest:clean
```

### `npm run clean:db`
Removes all data from Neo4j:
```bash
npm run clean:db
```
**âš ï¸ Warning**: This deletes everything!

### How ingestion works

The code is parsed using the configuration in `ragforge.config.yaml`:

```yaml
source:
  type: code
  adapter: typescript
  root: /home/luciedefraiteur/LR_CodeRag/ragforge/packages
  include:
    - "**/src/**/*.ts"
    - "**/lib/**/*.ts"
  exclude:
    - "**/node_modules/**"
    - "**/dist/**"
    # ... and 2 more
```

Each scope (function, class, method, etc.) gets:
- A unique UUID
- A content hash (for change detection)
- Relationships (DEFINED_IN, CALLS, IMPORTS, etc.)

## â­ Custom Methods (Generated from YAML Config)

This framework has been customized with methods generated from your `ragforge.config.yaml`:

### Custom Semantic Search Methods

- **`scope().semanticSearchBySource(query, { topK?, minScore? })`**
  Searches using `scopeSourceEmbeddings` (text-embedding-004, 768D, field: source)

**Example:**
```typescript
const results = await rag.scope()
  .semanticSearchBySource('your search query', { topK: 50 })
  .execute();
```

### Custom Relationship Methods

- **`scope().whereDefinedIn(targetName)`**
  Filter by DEFINED_IN relationship â€” Scope DEFINED_IN File
- **`scope().withDefinedIn(depth?)`**
  Expand DEFINED_IN relationships (default depth: 1)
- **`scope().whereConsumes(targetName)`**
  Filter by CONSUMES relationship â€” Scope CONSUMES Scope
- **`scope().withConsumes(depth?)`**
  Expand CONSUMES relationships (default depth: 1)
- **`scope().whereHasParent(targetName)`**
  Filter by HAS_PARENT relationship â€” Scope HAS_PARENT Scope
- **`scope().withHasParent(depth?)`**
  Expand HAS_PARENT relationships (default depth: 1)
- **`scope().whereUsesLibrary(targetName)`**
  Filter by USES_LIBRARY relationship â€” Scope USES_LIBRARY ExternalLibrary
- **`scope().withUsesLibrary(depth?)`**
  Expand USES_LIBRARY relationships (default depth: 1)
- **`scope().whereInheritsFrom(targetName)`**
  Filter by INHERITS_FROM relationship â€” Scope INHERITS_FROM Scope
- **`scope().withInheritsFrom(depth?)`**
  Expand INHERITS_FROM relationships (default depth: 1)

**Example:**
```typescript
// Filter by relationship
const filtered = await rag.scope()
  .whereDefinedIn('TargetName')
  .execute();

// Expand relationships
const expanded = await rag.scope()
  .whereName('CodeSourceAdapter')
  .withDefinedIn(2)  // Get relationships 2 levels deep
  .execute();
```

## ðŸ¤– LLM Reranking

The framework is pre-configured with a default LLM provider (Gemini API).
Use `.llmRerank()` to intelligently rerank results â€” **no need to create a provider!**

**Example:**
```typescript
const results = await rag.scope()
  .semanticSearchBySource('database connection', { topK: 50 })
  .llmRerank('where is the database connection initialized?', {
    topK: 10,        // Rerank top 50, return best 10
    minScore: 0.7    // Only high-confidence results
  })
  .execute();

// Access LLM reasoning
results.forEach(r => {
  console.log(`${r.entity.name}: ${r.score.toFixed(3)}`);
  if (r.scoreBreakdown?.llmReasoning) {
    console.log(`  Why: ${r.scoreBreakdown.llmReasoning}`);
  }
});
```

**When to use LLM reranking:**
- Complex queries requiring reasoning (e.g., "functions that handle errors gracefully")
- When semantic search returns too many similar results
- When you need understanding beyond keyword matching

**Tip:** Start with broad semantic search (topK: 50-100), then llmRerank to top 5-10.

## ðŸ“Š Pipeline Metadata & Observability

Use `.executeWithMetadata()` to get detailed information about each pipeline operation:

**Example:**
```typescript
const { results, metadata } = await rag.scope()
  .semanticSearchBySource('neo4j driver', { topK: 50 })
  .llmRerank('functions that create the neo4j driver', { topK: 10 })
  .executeWithMetadata();

// Inspect what happened in each step
metadata.operations.forEach(op => {
  console.log(`${op.type}: ${op.inputCount} â†’ ${op.outputCount} (${op.duration}ms)`);

  if (op.type === 'semantic') {
    console.log(`  Index: ${op.metadata?.vectorIndex}`);
    console.log(`  Model: ${op.metadata?.model} (${op.metadata?.dimension}D)`);
  }

  if (op.type === 'llmRerank') {
    console.log(`  LLM: ${op.metadata?.llmModel}`);
    // Access detailed reasoning for each result
    op.metadata?.evaluations?.forEach(e => {
      console.log(`    ${e.entityId}: ${e.score.toFixed(3)} - "${e.reasoning}"`);
    });
  }
});
```

### Custom Metadata Override

Add custom metadata to any operation:

```typescript
const { results, metadata } = await rag.scope()
  .semanticSearchBySource('typescript parser', {
    topK: 50,
    metadataOverride: (results, defaultMeta) => ({
      ...defaultMeta,
      customNote: 'Focused on TS parsing',
      avgScore: results.reduce((s, r) => s + r.score, 0) / results.length
    })
  })
  .llmRerank('libraries for parsing typescript', {
    topK: 10,
    metadataOverride: (results, defaultMeta) => ({
      ...defaultMeta,
      topResult: results[0]?.entity.name
    })
  })
  .executeWithMetadata();

// Access custom metadata
console.log(metadata.operations[0].metadata?.customNote);
console.log(metadata.operations[1].metadata?.topResult);
```

### Iterative Agent Helper

```typescript
import { createIterativeAgent } from './agent.js';
import type { LLMClient } from '@luciformresearch/ragforge-runtime';

const llm: LLMClient = /* wrap your LLM */;
const agent = createIterativeAgent({
  llm,
  workDir: './tmp',
  ragClientPath: './client.js'
});

const answer = await agent.answer('How does OAuth token refresh work?');
```

_Tip_: the runtime exposes `GeminiAPIProvider.fromEnv()` to bootstrap LLM reranking with `GEMINI_API_KEY`.

## Entity Reference

### Scope

Approximate nodes: 901

Usage: `const builder = rag.scope()`

**Searchable fields**
- `name` (string)
- `file` (string)
- `source` (string)

#### Query Builder Methods

- `where(filter: ScopeFilter)`
- `whereName(string | { contains?: string; startsWith?: string; endsWith?: string })`
- `whereFile(string | { contains?: string; startsWith?: string; endsWith?: string })`
- `whereSource(string | { contains?: string; startsWith?: string; endsWith?: string })`
- `semanticSearchBySource(query: string, options?: { topK?: number; minScore?: number })`
- `withDefinedIn(depth?: number)` â€” Scope DEFINED_IN File
- `withConsumes(depth?: number)` â€” Scope CONSUMES Scope
- `withHasParent(depth?: number)` â€” Scope HAS_PARENT Scope
- `withUsesLibrary(depth?: number)` â€” Scope USES_LIBRARY ExternalLibrary
- `withInheritsFrom(depth?: number)` â€” Scope INHERITS_FROM Scope
- `.limit(n)`, `.offset(n)`, `.orderBy(field, direction)`
- `.expand(relType, { depth?, direction? })` for arbitrary relationship traversal

#### Example

```typescript
const results = await rag.scope()
  .whereName({ contains: 'keyword' })
  .semanticSearchBySource('search query', { topK: 25 })
  .withDefinedIn(1)
  .limit(10)
  .execute();
```

## ðŸ“š Generated Examples

The following examples demonstrate how to use the generated RAG client:

### Semantic search by source
*Find code scopes by semantic similarity to source*

```typescript
console.log('ðŸ”Ž Semantic search for: "function printRootHelp..."');
  const results = await rag.scope()
    .semanticSearchBySource('function printRootHelp...', { topK: 50 })
    .execute();

  console.log(`\nFound ${results.length} results:`);
  results.slice(0, 5).forEach(r => {
    const entity = r.entity as any;
    console.log('  - ' + entity.name + ' (score: ' + r.score.toFixed(3) + ')');
  });
  if (results.length > 5) {
    console.log(`  ... and ${results.length - 5} more`);
  }}

export { semanticSearchBySource };
  // ... (14 more lines)
```

### Filter and expand by DEFINED_IN
*Find code scopes related through DEFINED_IN*

```typescript
console.log('ðŸ” Filtering by DEFINED_IN relationship...');
  const filtered = await rag.scope()
    .whereFileName('structured-llm-executor.ts')
    .execute();

  console.log(`\nFound ${filtered.length} items with DEFINED_IN relationship:`);
  filtered.slice(0, 5).forEach(r => {
    const entity = r.entity as any;
    console.log('  - ' + entity.name);
  });
  if (filtered.length > 5) {
    console.log(`  ... and ${filtered.length - 5} more`);
  }

  console.log('\nðŸ”— Expanding relationships from "CodeSourceAdapter"...');
  // ... (29 more lines)
```

### Filter and expand by CONSUMES
*Find code scopes related through CONSUMES*

```typescript
console.log('ðŸ” Filtering by CONSUMES relationship...');
  const filtered = await rag.scope()
    .whereConsumesScope('AddRelationshipConfig')
    .execute();

  console.log(`\nFound ${filtered.length} items with CONSUMES relationship:`);
  filtered.slice(0, 5).forEach(r => {
    const entity = r.entity as any;
    console.log('  - ' + entity.name);
  });
  if (filtered.length > 5) {
    console.log(`  ... and ${filtered.length - 5} more`);
  }

  console.log('\nðŸ”— Expanding relationships from "CodeSourceAdapter"...');
  // ... (29 more lines)
```

### Filter and expand by HAS_PARENT
*Find code scopes related through HAS_PARENT*

```typescript
console.log('ðŸ” Filtering by HAS_PARENT relationship...');
  const filtered = await rag.scope()
    .whereParentScope('CodeGenerator')
    .execute();

  console.log(`\nFound ${filtered.length} items with HAS_PARENT relationship:`);
  filtered.slice(0, 5).forEach(r => {
    const entity = r.entity as any;
    console.log('  - ' + entity.name);
  });
  if (filtered.length > 5) {
    console.log(`  ... and ${filtered.length - 5} more`);
  }

  console.log('\nðŸ”— Expanding relationships from "discoverFiles"...');
  // ... (29 more lines)
```

### Filter and expand by USES_LIBRARY
*Find code scopes related through USES_LIBRARY*

```typescript
console.log('ðŸ” Filtering by USES_LIBRARY relationship...');
  const filtered = await rag.scope()
    .whereUsesLibrary('path')
    .execute();

  console.log(`\nFound ${filtered.length} items with USES_LIBRARY relationship:`);
  filtered.slice(0, 5).forEach(r => {
    const entity = r.entity as any;
    console.log('  - ' + entity.name);
  });
  if (filtered.length > 5) {
    console.log(`  ... and ${filtered.length - 5} more`);
  }

  console.log('\nðŸ”— Expanding relationships from "CodeSourceAdapter"...');
  // ... (29 more lines)
```

### Filter and expand by INHERITS_FROM
*Find code scopes related through INHERITS_FROM*

```typescript
console.log('ðŸ” Filtering by INHERITS_FROM relationship...');
  const filtered = await rag.scope()
    .whereInheritsFrom('AddRelationshipConfig')
    .execute();

  console.log(`\nFound ${filtered.length} items with INHERITS_FROM relationship:`);
  filtered.slice(0, 5).forEach(r => {
    const entity = r.entity as any;
    console.log('  - ' + entity.name);
  });
  if (filtered.length > 5) {
    console.log(`  ... and ${filtered.length - 5} more`);
  }

  console.log('\nðŸ”— Expanding relationships from "CodeSourceAdapter"...');
  // ... (29 more lines)
```

### LLM reranking for better relevance
*Find most relevant code scopes using AI reasoning*

```typescript
console.log('ðŸ”Ž Semantic search: "function printRootHelp..."');
  console.log('ðŸ¤– Then reranking with LLM: "find the most relevant code scopes around this semantic search: function printRootHelp(): void {..."');

  // NOTE: llmRerank() can be used after ANY operation that returns results.
  // In this example, we use it after .semanticSearchBySource(), but you can also use it after:
  //   - Filters: .whereFileName(), .whereName(), .whereFile()
  //   - Relationships: .withDefinedIn(), .withConsumes()
  //   - Or even directly without prior operations
  const results = await rag.scope()
    .semanticSearchBySource('function printRootHelp...', { topK: 50 })
    .llmRerank('find the most relevant code scopes around this semantic search: function printRootHelp(): void {...', {
      topK: 10,
      minScore: 0.7
    })
    .execute();
  // ... (32 more lines)
```

### Pipeline metadata and observability
*Debug and optimize query pipelines*

```typescript
const { results, metadata } = await rag.scope()
    .semanticSearchBySource('function printRootHelp...', { topK: 50 })
    .llmRerank('find code scopes related to: function printRootHelp...', { topK: 10 })
    .executeWithMetadata();

  console.log(`Pipeline executed in ${metadata.totalDuration}ms`);
  console.log(`Final result count: ${metadata.finalCount}`);

  metadata.operations.forEach((op, idx) => {
    console.log(`\n[${idx + 1}] ${op.type.toUpperCase()}`);
    console.log(`  Duration: ${op.duration}ms`);
    console.log(`  Results: ${op.inputCount} â†’ ${op.outputCount}`);

    if (op.type === 'semantic' && op.metadata) {
      console.log(`  Index: ${op.metadata.vectorIndex}`);
  // ... (24 more lines)
```

### Complex multi-stage pipeline
*Build sophisticated queries with multiple operations*

```typescript
// Multi-stage pipeline:
  // 1. Semantic search (broad)
  // 2. Filter (focus)
  // 3. LLM rerank (quality)
  // 4. Expand relationships (complete context)
  // 5. Track metadata (observe)
  const { results, metadata } = await rag.scope()
    .semanticSearchBySource('function printRootHelp...', { topK: 100 })
    .whereFileName('index.ts')
    .llmRerank('find the most relevant code scopes', { topK: 20 })
    .withDefinedIn(1)
    .executeWithMetadata();

  console.log(`\nðŸŽ¯ Pipeline Results`);
  console.log(`Total time: ${metadata.totalDuration}ms`);
  // ... (30 more lines)
```

### Conditional search strategy
*Demonstrate decision-making based on result count and quality*

```typescript
// Initial broad search
  let results = await rag.scope()
    .semanticSearchBySource('query', { topK: 50 })
    .execute();

  console.log(`Found ${results.length} initial results`);

  // Decision 1: Too few results? Broaden query
  if (results.length < 5) {
    console.log('Too few results, broadening query...');
    results = await rag.scope()
      .semanticSearchBySource('broader query terms', { topK: 50 })
      .execute();
  }

  // ... (32 more lines)
```

### Breadth-first context exploration
*Map local context by exploring 1-hop relationships*

```typescript
// Find entry point
  const entry = await rag.scope()
    .whereName('CodeSourceAdapter')
    .execute();

  if (entry.length === 0) {
    console.log('Entry point not found');  }

  // Breadth-first: Get immediate neighborhood
  const context = await rag.scope()
    .whereName('CodeSourceAdapter')
    .withDefinedIn(1)
    .withConsumes(1)
    .withHasParent(1)
    .execute();
  // ... (24 more lines)
```

### Stopping criteria logic
*Show decision logic for iterative search with quality thresholds*

```typescript
const MAX_ITERATIONS = 3;
  const TARGET_RESULTS = 5;
  const MIN_SCORE = 0.8;

  let allResults: any[] = [];
  let iteration = 0;
  let shouldContinue = true;

  while (shouldContinue && iteration < MAX_ITERATIONS) {
    iteration++;
    console.log(`\nIteration ${iteration}`);

    // Progressive search strategy
    const query = iteration === 1 ? 'initial query' : 'refined query';

  // ... (40 more lines)
```

### CRUD operations with mutations
*mutation, crud, create, update, delete, relationships*

```typescript
console.log('ðŸ“š Testing CRUD mutations\n');

  // 1. Create a new scope
  console.log('1ï¸âƒ£ Creating a new scope...');
  const newScope: ScopeCreate = {
    uuid: 'scope-test-001',
    name: 'Sample name 1',
    file: 'Sample file 2',
    source: 'Sample source 3'
  };

  const createdScope = await rag.scopeMutations().create(newScope);
  console.log('âœ… Scope created:', createdScope);
  console.log();

  // ... (48 more lines)
```

### Batch mutations
*mutation, batch, createBatch, performance, transaction*

```typescript
console.log('ðŸ“¦ Testing batch mutations\n');

  // 1. Create multiple Scope entities in batch
  console.log('1ï¸âƒ£ Creating multiple scope entities in batch...');
  const newScopes: ScopeCreate[] = [
    {
      uuid: 'scope-batch-001',
      name: 'Sample Scope 1 name',
      file: 'Sample Scope 1 file'
    },
    {
      uuid: 'scope-batch-002',
      name: 'Sample Scope 2 name',
      file: 'Sample Scope 2 file'
    },
  // ... (41 more lines)
```

## Usage Patterns

- Start broad with semantic search (topK high), then filter or rerank.
- Use relationship helpers (with..., whereConsumesScope, etc.) to explore the graph.
- Combine semantic search and relationship expansion to build rich context.
- The iterative agent uses exactly these methods; provide clear objectives.

---
Generated automatically by RagForge.